Z_at_age[sp, sex, age, yr] <- M1_at_age[sp, sex, age] + F_results$F_spp_age[sp, sex, age, yr] + M2_at_age[sp, sex, age, yr]
}
}
# ** 6.9. FORECAST NUMBERS AT AGE, BIOMASS-AT-AGE (kg), and SSB-AT-AGE (kg) ----
# -- 6.9.1. Forecasted recruitment
# - Option 1: Use mean rec
if((proj_mean_rec == 1) & (srr_pred_fun > 1)) {
R[sp, yr] <- exp(log(avg_R[sp]) + rec_dev[sp, yr]) # Projections use mean R given bias in R0
}
# - Mean rec and environment
if((proj_mean_rec == 1) & (srr_pred_fun < 2)) {
beta_rec_tmp <- beta_rec_pars[sp,]
env_rec_tmp <- env_index_srr[yr,]
srr_mult <- sum(env_rec_tmp * beta_rec_tmp)
R[sp, yr] <- exp(log(avg_R[sp]) + rec_dev[sp, yr]) * exp(srr_mult)
}
# - Option 2: Use SRR and rec devs
if(proj_mean_rec == 0) {
if(srr_pred_fun == 0) { # Random about mean (e.g. Alaska)
R[sp, yr] <- R0[sp] * exp(rec_dev[sp, yr])
}
if(srr_pred_fun == 1) { # Random about mean with environmental effects
beta_rec_tmp <- beta_rec_pars[sp,]
env_rec_tmp <- env_index_srr[yr,]
srr_mult <- sum(env_rec_tmp * beta_rec_tmp)
R[sp, yr] <- R0[sp] * exp(rec_dev[sp, yr] + srr_mult)
}
if(srr_pred_fun == 2) { # Beverton-Holt
R[sp, yr] <- exp(rec_pars[sp, 1]) * ssb[sp, yr-minage[sp]] * exp(rec_dev[sp, yr]) /
(1 + exp(rec_pars[sp, 2]) * ssb[sp, yr-minage[sp]])
}
if(srr_pred_fun == 3) { # Beverton-Holt with environmental impacts on alpha
beta_rec_tmp <- beta_rec_pars[sp,]
env_rec_tmp <- env_index_srr[yr,]
srr_mult <- sum(env_rec_tmp * beta_rec_tmp)
srr_alpha <- exp(rec_pars[sp, 1] + srr_mult)
R[sp, yr] <- srr_alpha * ssb[sp, yr-minage[sp]] * exp(rec_dev[sp, yr]) /
(1 + exp(rec_pars[sp, 2]) * ssb[sp, yr-minage[sp]])
}
if(srr_pred_fun == 4) { # Ricker
R[sp, yr] <- exp(rec_pars[sp, 1]) * ssb[sp, yr-minage[sp]] *
exp(-exp(rec_pars[sp, 2]) * ssb[sp, yr-minage[sp]]/1000000.0) * exp(rec_dev[sp, yr])
}
if(srr_pred_fun == 5) { # Ricker with environmental impacts on alpha
beta_rec_tmp <- beta_rec_pars[sp,]
env_rec_tmp <- env_index_srr[yr,]
srr_mult <- sum(env_rec_tmp * beta_rec_tmp)
srr_alpha <- exp(rec_pars[sp, 1] + srr_mult)
R[sp, yr] <- srr_alpha * ssb[sp, yr-minage[sp]] *
exp(-exp(rec_pars[sp, 2]) * ssb[sp, yr-minage[sp]]/1000000.0) * exp(rec_dev[sp, yr])
}
}
N_at_age[sp, 1, 1, yr] <- R[sp, yr] * R_sexr[sp]
if(nsex[sp] > 1){
N_at_age[sp, 2, 1, yr] <- R[sp, yr] * (1 - R_sexr[sp])
}
# -- Ages > recruitment
for(age in 1:nages[sp]) {
for(sex in 1:nsex[sp]) {
# if(estDynamics[sp] == 0) { # Estimated numbers-at-age
# -- Where age < plus group
if(age < nages[sp]) {
N_at_age[sp, sex, age + 1, yr] <- N_at_age[sp, sex, age, yr - 1] * exp(-Z_at_age[sp, sex, age, yr-1])
}
# -- Plus group
if(age == nages[sp]) {
N_at_age[sp, sex, age, yr] <- N_at_age[sp, sex, age - 1, yr - 1] * exp(-Z_at_age[sp, sex, age-1, yr-1]) +
N_at_age[sp, sex, age, yr - 1] * exp(-Z_at_age[sp, sex, age, yr-1])
}
# } else if(estDynamics[sp] == 1) { # Fixed numbers-at-age - fixed scalar
#   N_at_age[sp, sex, age, yr] <- pop_scalar[sp, 1] * NByageFixed[sp, sex, age, yr]
# } else if(estDynamics[sp] == 2) { # Fixed numbers-at-age age-independent scalar
#   N_at_age[sp, sex, age, yr] <- pop_scalar[sp, 1] * NByageFixed[sp, sex, age, yr]
# } else if(estDynamics[sp] == 3) { # Fixed numbers-at-age age-dependent scalar
#   N_at_age[sp, sex, age, yr] <- pop_scalar[sp, age] * NByageFixed[sp, sex, age, yr]
# } else {
#   stop("Invalid 'estDynamics'")
# }
# Constraint to reduce population collapse
# pos_tmp <- posfun(N_at_age[sp, sex, age, yr], 0.001)
# N_at_age[sp, sex, age, yr] <- pos_tmp$ans
# zero_N_pen[sp] <- zero_N_pen[sp] + pos_tmp$penalty
# -- 6.9.4. FORECAST ssb BY AGE
biomass_at_age[sp, sex, age, yr] <- N_at_age[sp, sex, age, yr] * wt[pop_wt_index[sp], sex, age, nyrs_hind] # 6.5.
biomass[sp, yr] <- biomass[sp, yr] + biomass_at_age[sp, sex, age, yr]
} # End sex loop
# -- 6.9.5. FORECAST ssb (SUM ACROSS AGES)
ssb_at_age[sp, age, yr] <- N_at_age[sp, 1, age, yr] *
exp(-Z_at_age[sp, 1, age, yr] * (spawn_month[sp]/12.0)) *
wt[ssb_wt_index[sp], 1, age, nyrs_hind] * pmature_sexr[sp, age] # 6.6.
ssb[sp, yr] <- ssb[sp, yr] + ssb_at_age[sp, age, yr]
}
}
}
# * 6.10. ESTIMATE AVERAGE NUMBERS AT AGE ----
avgN_at_age <- switch(
avgnMode+1,
# Case 0: MSVPA approach
{
N_at_age *
(1 - exp(-Z_at_age)) / Z_at_age
},
# Case 1: Kinzey and Punt (2009) approximation
{
N_at_age *
exp(-Z_at_age / 2)
},
# Case 2: Van Kirk et al (2010) approximation
{
N_at_age
},
# Default case
{
stop("Invalid 'avgnMode'")
}
)
avgN_at_age
Z_at_age
avgN_at_age
avgN_at_age[is.nan(avgN_at_age)] <- 0
avgN_at_age
# ------------------------------------------------------------------------- #
# 7. RATION AND DIET ----
# ------------------------------------------------------------------------- #
# * 7.1. Calculate ration ----
ration <- calculate_ration(nspp, nyrs, max_nsex, max_nages, nyrs_hind, Ceq, Qc, Tcm, Tco, Tcl,
CK1, CK4, CA, CB, fday, env_index, Cindex,
wt, pop_wt_index, Pvalue, Pyrs, nsex, nages)
# * 7.2. Reorganize stomach content ----
diet_prop <- reorganize_stomach_content(stom_prop_obs, stom_prop_ctl, minage, nspp,
nyrs, nsex, nages, max_nsex, max_nages, nyrs_hind, styr)
# * 7.3. Calculate other food stomach content ----
other_food_diet_prop <- calculate_other_food_diet_prop(nyrs, nspp, nsex, nages, max_nsex, max_nages,
diet_prop, other_food)
diet_prop
sum(diet_prop)
stom_prop_obs
sum(stom_prop_obs)
sum(stom_prop_obs[,2])
diet_prop
sum(diet_prop)
# Initialize outputs
n_obs <- nrow(stom_prop_obs)
r_sexes <- matrix(0, nrow=n_obs, ncol=2)
k_sexes <- matrix(0, nrow=n_obs, ncol=2)
# Correct dimensions for diet_prop
diet_prop <- array(0, dim=c(nspp, max_nsex, max_nages, nspp, max_nsex, max_nages, nyrs))
# Precompute indices for predator and prey
rsp <- stom_prop_ctl[, 1]      # Index of predator
ksp <- stom_prop_ctl[, 2]      # Index of prey
r_sex <- stom_prop_ctl[, 3]    # Index of predator sex
k_sex <- stom_prop_ctl[, 4]    # Index of prey sex
r_age <- stom_prop_ctl[, 5] - minage[rsp] + 1  # Index of predator age
k_age <- stom_prop_ctl[, 6] - minage[ksp] + 1 # Index of prey age
flt_yr <- stom_prop_ctl[, 7]   # Index of year
max_nsex
# Set predator and prey sex indices
# - diet is assumed sex-invariant
if(max_nsex > 2){
r_sexes[, ] <- cbind(ifelse(r_sex > 0, r_sex-1, 0), ifelse(r_sex > 0, r_sex-1, 1))
k_sexes[, ] <- cbind(ifelse(k_sex > 0, k_sex-1, 0), ifelse(k_sex > 0, k_sex-1, 1))
}
r_sexes
k_sexes
r_sex
# Initialize outputs
n_obs <- nrow(stom_prop_obs)
r_sexes <- matrix(1, nrow=n_obs, ncol=2)
k_sexes <- matrix(1, nrow=n_obs, ncol=2)
# Correct dimensions for diet_prop
diet_prop <- array(0, dim=c(nspp, max_nsex, max_nages, nspp, max_nsex, max_nages, nyrs))
# Precompute indices for predator and prey
rsp <- stom_prop_ctl[, 1]      # Index of predator
ksp <- stom_prop_ctl[, 2]      # Index of prey
r_sex <- stom_prop_ctl[, 3]    # Index of predator sex
k_sex <- stom_prop_ctl[, 4]    # Index of prey sex
r_age <- stom_prop_ctl[, 5] - minage[rsp] + 1  # Index of predator age
k_age <- stom_prop_ctl[, 6] - minage[ksp] + 1 # Index of prey age
flt_yr <- stom_prop_ctl[, 7]   # Index of year
# Set predator and prey sex indices for joint sex data
# - Sex = 0 by nsex = 2
if(nsex[rsp] == 2){
r_sexes[, ] <- cbind(ifelse(r_sex > 0, r_sex, 1), ifelse(r_sex > 0, r_sex, 2))
}
nsex
nsex[rsp]
rsp
# Initialize outputs
n_obs <- nrow(stom_prop_obs)
r_sexes <- matrix(1, nrow=n_obs, ncol=2)
k_sexes <- matrix(1, nrow=n_obs, ncol=2)
# Correct dimensions for diet_prop
diet_prop <- array(0, dim=c(nspp, max_nsex, max_nages, nspp, max_nsex, max_nages, nyrs))
# Precompute indices for predator and prey
rsp <- stom_prop_ctl[, 1]      # Index of predator
ksp <- stom_prop_ctl[, 2]      # Index of prey
r_sex <- stom_prop_ctl[, 3]    # Index of predator sex
k_sex <- stom_prop_ctl[, 4]    # Index of prey sex
r_age <- stom_prop_ctl[, 5] - minage[rsp] + 1  # Index of predator age
k_age <- stom_prop_ctl[, 6] - minage[ksp] + 1 # Index of prey age
flt_yr <- stom_prop_ctl[, 7]   # Index of year
# Set predator and prey sex indices for joint sex data
# - Sex = 0 by nsex = 2
if(max_nsex > 2){
r_sexes[, ] <- cbind(ifelse(r_sex > 0, r_sex, 1), ifelse(r_sex > 0, r_sex, 2))
k_sexes[, ] <- cbind(ifelse(k_sex > 0, k_sex, 1), ifelse(k_sex > 0, k_sex, 2))
}
# Process for each observation
for(stom_ind in 1:n_obs) {
# Extract current indices
current_rsp <- as.integer(rsp[stom_ind])
current_ksp <- as.integer(ksp[stom_ind])
current_r_age <- as.integer(r_age[stom_ind])
current_k_age <- as.integer(k_age[stom_ind])
current_diet_yr <- as.integer(flt_yr[stom_ind])
if(current_diet_yr > 0) { # Annual diet data
yr <- current_diet_yr - styr + 1
if(yr < nyrs_hind) {
diet_prop[current_rsp, r_sexes[stom_ind, 1], current_r_age,
current_ksp, k_sexes[stom_ind, 1], current_k_age, yr] <- as.numeric(stom_prop_obs[stom_ind, 2])
}
}
if(current_diet_yr == 0) { # Average diet data
diet_prop[current_rsp, r_sexes[stom_ind, 1], current_r_age,
current_ksp, k_sexes[stom_ind, 1], current_k_age, ] <- stom_prop_obs[stom_ind, 2]
}
}
sum(diet_prop)
stom_prop_obs
stom_prop_obs[,2]
sum(stom_prop_obs[,2])
diet_prop
flt_yr
sum(diet_prop[,,,,,,1])
sum(stom_prop_obs[,2])
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
# ------------------------------------------------------------------------- #
# 7. RATION AND DIET ----
# ------------------------------------------------------------------------- #
# * 7.1. Calculate ration ----
ration <- calculate_ration(nspp, nyrs, max_nsex, max_nages, nyrs_hind, Ceq, Qc, Tcm, Tco, Tcl,
CK1, CK4, CA, CB, fday, env_index, Cindex,
wt, pop_wt_index, Pvalue, Pyrs, nsex, nages)
# * 7.2. Reorganize stomach content ----
diet_prop <- reorganize_stomach_content(stom_prop_obs, stom_prop_ctl, minage, nspp,
nyrs, nsex, nages, max_nsex, max_nages, nyrs_hind, styr)
# * 7.3. Calculate other food stomach content ----
other_food_diet_prop <- calculate_other_food_diet_prop(nyrs, nspp, nsex, nages, max_nsex, max_nages,
diet_prop, other_food)
other_food_diet_prop
sum(other_food_diet_prop)
sum(other_food_diet_prop[,,,1])
other_food
# Initialize array for other food diet proportions
other_food_diet_prop <- array(1, dim = c(nspp, max_nsex, max_nages, nyrs))
# Loop through years
for(yr in 1:nyrs) {
for(rsp in 1:nspp) { # Loop through predator species
for(r_sex in 1:nsex[rsp]) { # Loop through predator sex
for(r_age in 1:nages[rsp]) { # Loop through predator age
# Subtract diet proportions for all prey items
other_food_diet_prop[rsp, r_sex, r_age, yr] = 1 -
sum(diet_prop[rsp, r_sex, r_age, , , , yr])
# Apply other food penalties
if(other_food[rsp] > 0) {
other_food_diet_prop[rsp, r_sex, r_age, yr] <-
other_food_diet_prop[rsp, r_sex, r_age, yr] / other_food[rsp]
}
if(other_food[rsp] == 0) {
other_food_diet_prop[rsp, r_sex, r_age, yr] <- 0
}
}
}
}
}
other_food_diet_prop
sum(other_food_diet_prop)
sum(other_food_diet_prop[,,,1])
sum(diet_prop[,,,,,,1])
#' @param max_nsex
#' @param max_nages
#'
#' @return Array of other food diet proportions [pred_sp, pred_sex, pred_age, year]
#'
#' @details
#' The function initializes other food diet proportion as 1 and subtracts the proportions
#' of all other prey species. If other food value exists for a predator species (>0),
#' the proportion is penalized by dividing by the other food value.
#'
calculate_other_food_diet_prop <- function(nyrs, nspp, nsex, nages, max_nsex, max_nages, diet_prop, other_food) {
# Initialize array for other food diet proportions
other_food_diet_prop <- array(1, dim = c(nspp, max_nsex, max_nages, nyrs))
# Loop through years
for(yr in 1:nyrs) {
for(rsp in 1:nspp) { # Loop through predator species
for(r_sex in 1:nsex[rsp]) { # Loop through predator sex
for(r_age in 1:nages[rsp]) { # Loop through predator age
# Subtract diet proportions for all prey items
other_food_diet_prop[rsp, r_sex, r_age, yr] = 1 -
sum(diet_prop[rsp, r_sex, r_age, , , , yr])
# Apply other food penalties
if(other_food[rsp] > 0) {
other_food_diet_prop[rsp, r_sex, r_age, yr] <-
other_food_diet_prop[rsp, r_sex, r_age, yr] / other_food[rsp]
}
if(other_food[rsp] == 0) {
other_food_diet_prop[rsp, r_sex, r_age, yr] <- 0
}
}
}
}
}
return(other_food_diet_prop)
}
# * 7.2. Reorganize stomach content ----
diet_prop <- reorganize_stomach_content(stom_prop_obs, stom_prop_ctl, minage, nspp,
nyrs, nsex, nages, max_nsex, max_nages, nyrs_hind, styr)
# * 7.3. Calculate other food stomach content ----
other_food_diet_prop <- calculate_other_food_diet_prop(nyrs, nspp, nsex, nages, max_nsex, max_nages,
diet_prop, other_food)
suit_list <- calculate_MSVPA_suitability(diet_prop, avgN_at_age, wt, pop_wt_index,
other_food_diet_prop, nspp, nsex, max_nsex, nages, max_nages, nyrs,
nyrs_hind, suit_styr, suit_endyr, nyrs_suit,
msmMode)
# Initialize arrays
stom_div_bio <- array(0, dim = c(nspp, max_nsex, max_nages, nspp, max_nsex, max_nages, nyrs))
suma_suit <- array(0, dim = c(nspp, max_nsex, max_nages, nyrs))
suit_main <- array(0, dim = c(nspp, max_nsex, max_nages, nspp, max_nsex, max_nages, nyrs))
suit_other <- array(1, dim = c(nspp, max_nsex, max_nages, nyrs))
# Calculate stomach proportion over biomass
for(yr in 1:nyrs) {
for(ksp in 1:nspp) {
for(rsp in 1:nspp) {
for(k_sex in 1:nsex[ksp]) {
for(r_sex in 1:nsex[rsp]) {
for(r_age in 1:nages[rsp]) {
for(k_age in 1:nages[ksp]) {
if(yr < nyrs_hind){
yr_ind <- yr
}
if(yr >= nyrs_hind){
yr_ind <- nyrs_hind
}
#if(avgN_at_age[ksp, k_sex, k_age, yr] > 0) {
stom_div_bio[rsp, r_sex, r_age, ksp, k_sex, k_age, yr] <-
diet_prop[rsp, r_sex, r_age, ksp, k_sex, k_age, yr] /
avgN_at_age[ksp, k_sex, k_age, yr]
if(msmMode == 2) {
stom_div_bio[rsp, r_sex, r_age, ksp, k_sex, k_age, yr] <-
stom_div_bio[rsp, r_sex, r_age, ksp, k_sex, k_age, yr] /
avgN_at_age[ksp, k_sex, k_age, yr]
}
# }
# Handle non-finite values
# if(!is.finite(stom_div_bio[as.integer(rsp + (nspp * (r_sex-1))),
#                            as.integer(ksp + (nspp * (k_sex-1))),
#                            r_age, k_age, yr])) {
#   stom_div_bio[as.integer(rsp + (nspp * (r_sex-1))),
#                as.integer(ksp + (nspp * (k_sex-1))),
#                r_age, k_age, yr] <- 0
# }
if(wt[pop_wt_index[ksp], k_sex, k_age, yr_ind] != 0) {
stom_div_bio[rsp, r_sex, r_age, ksp, k_sex, k_age, yr] <-
stom_div_bio[rsp, r_sex, r_age, ksp, k_sex, k_age, yr] /
wt[pop_wt_index[ksp], k_sex, k_age, yr_ind]
suma_suit[rsp, r_sex, r_age, yr] <-
suma_suit[rsp, r_sex, r_age, yr] +
stom_div_bio[rsp, r_sex, r_age, ksp, k_sex, k_age, yr]
}
}
}
}
}
}
}
}
# Calculate suitability
for(rsp in 1:nspp) {
for(r_sex in 1:nsex[rsp]) {
for(r_age in 1:nages[rsp]) {
for(ksp in 1:nspp) {
for(k_sex in 1:nsex[ksp]) {
for(k_age in 1:nages[ksp]) {
# Calculate average suitability
for(yr in suit_styr:suit_endyr) {
# if(suma_suit[rsp, r_sex, r_age, yr] +
#    other_food_diet_prop[rsp, r_sex, r_age, yr] > 0) {
suit_main[rsp, r_sex, r_age, ksp, k_sex, k_age, 1] <-
suit_main[rsp, r_sex, r_age, ksp, k_sex, k_age, 1] +
stom_div_bio[rsp, r_sex, r_age, ksp, k_sex, k_age, yr] /
(suma_suit[rsp, r_sex, r_age, yr] +
other_food_diet_prop[rsp, r_sex, r_age, yr])
# }
}
# Average across years
suit_main[rsp, r_sex, r_age, ksp, k_sex, k_age, 1] <-
suit_main[rsp, r_sex, r_age, ksp, k_sex, k_age, 1] / nyrs_suit
# # Handle non-finite values
# if(!is.finite(suit_main[as.integer(rsp + (nspp * (r_sex-1))),
#                         as.integer(ksp + (nspp * (k_sex-1))),
#                         r_age, k_age, 1])) {
#   suit_main[as.integer(rsp + (nspp * (r_sex-1))),
#             as.integer(ksp + (nspp * (k_sex-1))),
#             r_age, k_age, 1] <- 0
# }
# Fill in remaining years
for(yr in 2:nyrs) {
suit_main[rsp, r_sex, r_age, ksp, k_sex, k_age, yr] <-
suit_main[rsp, r_sex, r_age, ksp, k_sex, k_age, 1]
}
# Calculate other suitability
for(yr in 1:nyrs) {
suit_other[rsp, r_sex, r_age, yr] <-
suit_other[rsp, r_sex, r_age, yr] -
suit_main[rsp, r_sex, r_age, ksp, k_sex, k_age, yr]
}
}
}
}
}
}
}
suit_styr
suit_endyr
x = 10
y = 1
abs(x-y)
abs(x-y)+x
abs(x-y)+x+y
devtools::document()
abs(-10)
abs(-10)+10
abs(-10)-10
.8/.9
log(.8/.9)
log(.9/.9)
log(.9/.8)
devtools::document()
?build_srr
# Grant Adams, Kirstin Holsman, Andre Punt - April 2019
# Code to run Bering Sea CEATTLE model in TMB
# Citation:
# Holsman, K. K., Ianelli, J., Aydin, K., Punt, A. E., and Moffitt, E. A. 2015. A comparison of fisheries biological reference points estimated from temperature-specific multi-species and single-species climate-enhanced stock assessment models. Deep-Sea Research Part II: Topical Studies in Oceanography, 134: 360–378.
library(Rceattle)
################################################
# Data
################################################
# Example
# To run the 2017 single species assessment for the Bering Sea, a data file must first be loaded:
data("BS2017SS") # Single-species data. ?BS2017SS for more information on the data
data("BS2017MS") # Multi-species data. Note: the only difference is the residual mortality (M1_base) is lower
# Write data to excel
Rceattle::write_data(data_list = BS2017SS, file = "BS2017SS.xlsx")
# Change the data how you want in excel
# Read the data back in
mydata <- Rceattle::read_data( file = "BS2017SS.xlsx")
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
plot_biomass(ss_run)
ss_run$run_time
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
ss_run$run_time
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = FALSE,
verbose = 1)
ss_run$run_time
