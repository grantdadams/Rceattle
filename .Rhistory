#   N_at_age[sp, sex, age, yr] <- pop_scalar[sp, 1] * NByageFixed[sp, sex, age, yr]
# } else if(estDynamics[sp] == 3) { # Fixed numbers-at-age age-dependent scalar
#   N_at_age[sp, sex, age, yr] <- pop_scalar[sp, age] * NByageFixed[sp, sex, age, yr]
# } else {
#   stop("Invalid 'estDynamics'")
# }
# Constraint to reduce population collapse
# pos_tmp <- posfun(N_at_age[sp, sex, age, yr], 0.001)
# N_at_age[sp, sex, age, yr] <- pos_tmp$ans
# zero_N_pen[sp] <- zero_N_pen[sp] + pos_tmp$penalty
# -- 6.9.4. FORECAST ssb BY AGE
biomass_at_age[sp, sex, age, yr] <- N_at_age[sp, sex, age, yr] * wt[pop_wt_index[sp], sex, age, nyrs_hind] # 6.5.
biomass[sp, yr] <- biomass[sp, yr] + biomass_at_age[sp, sex, age, yr]
} # End sex loop
# -- 6.9.5. FORECAST ssb (SUM ACROSS AGES)
ssb_at_age[sp, age, yr] <- N_at_age[sp, 1, age, yr] *
exp(-Z_at_age[sp, 1, age, yr] * (spawn_month[sp]/12.0)) *
wt[ssb_wt_index[sp], 1, age, nyrs_hind] * pmature_sexr[sp, age] # 6.6.
ssb[sp, yr] <- ssb[sp, yr] + ssb_at_age[sp, age, yr]
}
}
}
# * 6.10. ESTIMATE AVERAGE NUMBERS AT AGE ----
avgN_at_age <- switch(
avgnMode+1,
# Case 0: MSVPA approach
{
N_at_age *
(1 - exp(-Z_at_age)) / Z_at_age
},
# Case 1: Kinzey and Punt (2009) approximation
{
N_at_age *
exp(-Z_at_age / 2)
},
# Case 2: Van Kirk et al (2010) approximation
{
N_at_age
},
# Default case
{
stop("Invalid 'avgnMode'")
}
)
# ------------------------------------------------------------------------- #
# 7. RATION AND DIET ----
# ------------------------------------------------------------------------- #
# * 7.1. Calculate ration ----
ration <- calculate_ration(nspp, nyrs, max_nsex, max_nages, nyrs_hind, Ceq, Qc, Tcm, Tco, Tcl,
CK1, CK4, CA, CB, fday, env_index, Cindex,
wt, pop_wt_index, Pvalue, Pyrs, nsex, nages)
# * 7.2. Reorganize stomach content ----
diet_prop <- reorganize_stomach_content(stom_prop_obs, stom_prop_ctl, minage, nspp,
nyrs, nsex, nages, max_nsex, max_nages, nyrs_hind, styr)
# * 7.3. Calculate other food stomach content ----
other_food_diet_prop <- calculate_other_food_diet_prop(nyrs, nspp, nsex, nages, max_nsex, max_nages,
diet_prop, other_food)
# ------------------------------------------------------------------------- #
# 8. START PREDATION ----
# ------------------------------------------------------------------------- #
if (msmMode > 0) {
# ------------------------------------------------------------------------- #
# * 8.1. SUITABILITY EQUATIONS ----
# ------------------------------------------------------------------------- #
# 8.1.1. Holsman and MSVPA based suitability # FIXME - not flexible for interannual variation
if (suitMode == 0) {
suit_list <- calculate_MSVPA_suitability(diet_prop, avgN_at_age, wt, pop_wt_index,
other_food_diet_prop, nspp, nsex, nages, nyrs,
nyrs_hind, suit_styr, suit_endyr, nyrs_suit,
msmMode)
}
# 8.1.2. GAMMA suitability
if(suitMode %in% c(0,1)){
suit_list <- calculate_gamma_suitability(nspp, nages, nsex, nyrs, nyrs_hind,
max_nages, max_nsex,
laa, wt, pop_wt_index, vulnerability,
vulnerability_other, gam_a, gam_b, suitMode)
}
# 8.1.3. Lognormal suitability
if(suitMode %in% c(0,1)){
suit_list <- calculate_lognormal_suitability(nspp, nages, nsex, nyrs, nyrs_hind,
max_nages, max_nsex,
laa, wt, pop_wt_index, vulnerability,
vulnerability_other, gam_a, gam_b, suitMode)
}
# ------------------------------------------------------------------------- #
# * 8.2. PREDATION MORTALITY EQUATIONS ----
# ------------------------------------------------------------------------- #
# -- 8.2.1. MSVPA PREDATION MORTALITY
if ((msmMode == 1) | (msmMode == 2)) {
predation_results <- calculate_predation(nspp, nsex, nages, nyrs, nyrs_hind,
max_nages, max_nsex,
avgN_at_age, suit_list$suit_main, suit_list$suit_other, other_food,
wt, pop_wt_index, ration, msmMode)
# Update M2 array
M2_at_age <- predation_results$M2_at_age
}
} # Predation loop
} # Population dynamics loop (niter)
# ------------------------------------------------------------------------- #
# 9. INDEX EQUATIONS ----
# ------------------------------------------------------------------------- #
# * 9.1. Index of abundance/biomass ----
index_hat <- calculate_abundance_index(index_ctl, index_n, N_at_age, Z_at_age, sel,
wt, flt_units, flt_wt_index, nages, nsex,
nyrs_hind, styr)
# * 9.2. Analytical survey q following Ludwig and Martell 1994 ----
index_q_analytical <- calculate_analytical_q(index_ctl, index_n, index_obs, index_hat,
est_sigma_index, est_index_q, n_flt, nyrs_hind, styr)
for(index in 1:n_flt) {
# Set index_q to analytical if used
if(est_index_q[index] == 3 & flt_type[index] == 2) {
index_q[index, ] <- rep(index_q_analytical[index], nyrs_hind)
}
}
# * 9.3. Survey Biomass - multiply by q ----
# - Extract necessary columns for vectorized operations
indices <- index_ctl[, 1]       # Temporary survey indices (1-based)
flt_yrs <- index_ctl[, 3]       # Temporary index for years of data
# - Adjust flt_yrs
flt_yrs[flt_yrs > 0] <- flt_yrs[flt_yrs > 0] - styr + 1
flt_yrs[flt_yrs < 0] <- -flt_yrs[flt_yrs < 0] - styr + 1
# - Determine yr_ind based on flt_yrs
yr_inds <- flt_yrs
yr_inds[flt_yrs > nyrs_hind] <- nyrs_hind
# - Ensure indices are within valid bounds
valid_indices <- indices > 0 & indices <= ncol(index_q) & yr_inds > 0 & yr_inds <= nyrs_hind
# - Update index_hat only for valid indices
index_hat[valid_indices] <- index_q[cbind(indices[valid_indices], yr_inds[valid_indices])] * index_hat[valid_indices]
# - Optionally, handle cases where indices were out of bounds
if (any(!valid_indices)) {
warning("Some indices were out of bounds.")
}
# * 9.4. Calculate analytical sigma following Ludwig and Walters 1994 ----
ln_index_analytical_sd <- calculate_analytical_sd(index_ctl, index_obs, index_hat, n_flt, nyrs_hind, styr)
catch_hat <- estimate_catch(catch_ctl, catch_n, F_results$F_flt_age, Z_at_age, N_at_age,
wt, sel, flt_wt_index, proj_F_prop, flt_units,
nsex, nages, styr, nyrs_hind)
# * 10.2 Exploitable biomass ----
exploitable_biomass <- calculate_exploitable_biomass(n_flt, flt_spp, flt_type, nyrs, nyrs_hind,
nages, nsex, N_at_age, wt, sel,
flt_wt_index, proj_F_prop)
# ------------------------------------------------------------------------- #
# 11. COMPOSITION EQUATIONS ----
# ------------------------------------------------------------------------- #
comp_hat <- estimate_comp(comp_ctl, comp_n, comp_obs, F_results$F_flt_age, Z_at_age, N_at_age,
sel, index_q, age_error, age_trans_matrix,
flt_type, nages, nlengths, nsex, styr,
nyrs_hind, flt_age_transition_index)
# Initialize outputs
age_obs_hat <- matrix(0, nrow=nrow(comp_obs), ncol=ncol(comp_obs))            # Estimated catch at observed age (accounts for ageing error)
comp_hat <- matrix(0, nrow=nrow(comp_obs), ncol=ncol(comp_obs))               # Estimated comp
age_hat <- matrix(0, nrow=nrow(comp_obs), ncol=ncol(comp_obs))                # Estimated catch at true age
true_age_comp_hat  <- matrix(0, nrow=nrow(comp_obs), ncol=ncol(comp_obs))     # True estimated age composition
# Loop through composition data
for(comp_ind in 1:nrow(comp_ctl)) {
# Extract indices
flt <- comp_ctl[comp_ind, 1]
sp <- comp_ctl[comp_ind, 2]
flt_sex <- comp_ctl[comp_ind, 3]
comp_type <- comp_ctl[comp_ind, 4]
yr <- comp_ctl[comp_ind, 5]
mo <- comp_n[comp_ind, 1]
# Year calculations
if(yr > 0) yr <- yr - styr + 1
if(yr < 0) yr <- -yr - styr + 1
# Determine year index for projections
yr_ind <- yr
if(yr > nyrs_hind) {yr_ind <- nyrs_hind}
# Calculate catch at age
for(age in 1:nages[sp]) {
if(flt_type[flt] == 1) { # Fishery
# Handle different sex cases
if(flt_sex == 0) { # Combined sexes
for(sex in 1:nsex[sp]) {
age_hat[comp_ind, age] <- age_hat[comp_ind, age] +
F_flt_age[flt, sex, age, yr] / Z_at_age[sp, sex, age, yr] *
(1 - exp(-Z_at_age[sp, sex, age, yr])) * N_at_age[sp, sex, age, yr]
}
# age_hat[comp_ind, age] <- sum(
#   F_flt_age[flt, 1:nsex[sp], age, yr] / Z_at_age[sp, 1:nsex[sp], age, yr] *
#     (1 - exp(-Z_at_age[sp, 1:nsex[sp], age, yr])) * N_at_age[sp, 1:nsex[sp], age, yr])
}
if (flt_sex >= 1 && flt_sex <= 2) { # Sex-specific composition data
sex <- flt_sex
age_hat[comp_ind, age] <- F_flt_age[flt, sex, age, yr] / Z_at_age[sp, sex, age, yr] *
(1 - exp(-Z_at_age[sp, sex, age, yr])) * N_at_age[sp, sex, age, yr]
}
if (flt_sex == 3) { # Joint composition data
for(sex in 1:nsex[sp]) {
age_hat[comp_ind, age + nages[sp] * (sex - 1)] <- F_flt_age[flt, sex, age, yr] / Z_at_age[sp, sex, age, yr] *
(1 - exp(-Z_at_age[sp, sex, age, yr])) * N_at_age[sp, sex, age, yr]
}
}
}
if (flt_type[flt] == 2) { # Survey
if(flt_sex == 0) { # Combined sexes
for(sex in 1:nsex[sp]) {
age_hat[comp_ind, age] <- age_hat[comp_ind, age] +
N_at_age[sp, sex, age, yr] * sel[flt, sex, age, yr_ind] *
index_q[flt, yr_ind] * exp(-(mo / 12.0) * Z_at_age[sp, sex, age, yr])
}
# age_hat[comp_ind, age] <- sum(N_at_age[sp, 1:nsex[sp], age, yr] * sel[flt, 1:nsex[sp], age, yr_ind] *
#                                 index_q[flt, yr_ind] * exp(-(mo / 12.0) * Z_at_age[sp, 1:nsex[sp], age, yr]))
}
if (flt_sex >= 1 && flt_sex <= 2) { # Sex-specific composition data
sex <- flt_sex
age_hat[comp_ind, age] <- N_at_age[sp, sex, age, yr] * sel[flt, sex, age, yr_ind] *
index_q[flt, yr_ind] * exp(-(mo / 12.0) * Z_at_age[sp, sex, age, yr])
}
if (flt_sex == 3) { # Joint composition data
for(sex in 1:nsex[sp]) {
age_hat[comp_ind, age + nages[sp] * (sex - 1)] <- N_at_age[sp, sex, age, yr] * sel[flt, sex, age, yr_ind] *
index_q[flt, yr_ind] * exp(-(mo / 12.0) * Z_at_age[sp, sex, age, yr])
}
}
}
}
# Adjustment for joint sex composition data
joint_adjust <- 1
if(flt_sex == 3){joint_adjust <- 2}
# Get true age comp
true_age_comp_hat[comp_ind, 1:(nages[sp] * joint_adjust)] <- age_hat[comp_ind, 1:(nages[sp] * joint_adjust)] / sum(age_hat[comp_ind, 1:(nages[sp] * joint_adjust)])
# Adjust for aging error
# - Combined or single-sex
age_obs_hat[comp_ind, 1:nages[sp]] <- age_hat[comp_ind, 1:nages[sp]] %*% age_error[sp, 1:nages[sp], 1:nages[sp]]
# # Adjust for aging error for
# - joint data
if(flt_sex == 3) {
age_obs_hat[comp_ind, (nages[sp] + 1):(nages[sp] * 2)] <- age_hat[comp_ind, (nages[sp] + 1):(nages[sp] * 2)] %*% age_error[sp, 1:nages[sp], 1:nages[sp]]
}
# Survey catch-at-age - standardize to sum to 1
if (comp_type == 0) {
comp_hat[comp_ind, ] <- age_obs_hat[comp_ind, ] / sum(age_obs_hat[comp_ind, ])
}
# Catch-at-length
if (comp_type == 1) {
sex <- 1
if(flt_sex > 0 & flt_sex < 3) {sex = flt_sex} # Adjust sex for males/females
# Convert from catch-at-age to catch-at-length
# - Combined or single-sex
comp_hat[comp_ind, 1:nlengths[sp]] <- age_obs_hat[comp_ind, 1:nages[sp]] %*% age_trans_matrix[flt_age_transition_index[flt], sex, 1:nages[sp], 1:nlengths[sp]]
# Convert from catch-at-age to catch-at-length for
# - joint comp data
if (flt_sex == 3) {
sex = 2
comp_hat[comp_ind, (nlengths[sp] + 1):(nlengths[sp] * 2)] <- age_obs_hat[comp_ind, (nages[sp] + 1):(nages[sp] * 2)] %*% age_trans_matrix[flt_age_transition_index[flt], sex, 1:nages[sp], 1:nlengths[sp]]
}
# Standardize to sum to 1
comp_hat[comp_ind, ] <- comp_hat[comp_ind, ] / sum(comp_hat[comp_ind, ])
}
}
F_flt_age <- F_results$F_flt_age
# Loop through composition data
for(comp_ind in 1:nrow(comp_ctl)) {
# Extract indices
flt <- comp_ctl[comp_ind, 1]
sp <- comp_ctl[comp_ind, 2]
flt_sex <- comp_ctl[comp_ind, 3]
comp_type <- comp_ctl[comp_ind, 4]
yr <- comp_ctl[comp_ind, 5]
mo <- comp_n[comp_ind, 1]
# Year calculations
if(yr > 0) yr <- yr - styr + 1
if(yr < 0) yr <- -yr - styr + 1
# Determine year index for projections
yr_ind <- yr
if(yr > nyrs_hind) {yr_ind <- nyrs_hind}
# Calculate catch at age
for(age in 1:nages[sp]) {
if(flt_type[flt] == 1) { # Fishery
# Handle different sex cases
if(flt_sex == 0) { # Combined sexes
for(sex in 1:nsex[sp]) {
age_hat[comp_ind, age] <- age_hat[comp_ind, age] +
F_flt_age[flt, sex, age, yr] / Z_at_age[sp, sex, age, yr] *
(1 - exp(-Z_at_age[sp, sex, age, yr])) * N_at_age[sp, sex, age, yr]
}
# age_hat[comp_ind, age] <- sum(
#   F_flt_age[flt, 1:nsex[sp], age, yr] / Z_at_age[sp, 1:nsex[sp], age, yr] *
#     (1 - exp(-Z_at_age[sp, 1:nsex[sp], age, yr])) * N_at_age[sp, 1:nsex[sp], age, yr])
}
if (flt_sex >= 1 && flt_sex <= 2) { # Sex-specific composition data
sex <- flt_sex
age_hat[comp_ind, age] <- F_flt_age[flt, sex, age, yr] / Z_at_age[sp, sex, age, yr] *
(1 - exp(-Z_at_age[sp, sex, age, yr])) * N_at_age[sp, sex, age, yr]
}
if (flt_sex == 3) { # Joint composition data
for(sex in 1:nsex[sp]) {
age_hat[comp_ind, age + nages[sp] * (sex - 1)] <- F_flt_age[flt, sex, age, yr] / Z_at_age[sp, sex, age, yr] *
(1 - exp(-Z_at_age[sp, sex, age, yr])) * N_at_age[sp, sex, age, yr]
}
}
}
if (flt_type[flt] == 2) { # Survey
if(flt_sex == 0) { # Combined sexes
for(sex in 1:nsex[sp]) {
age_hat[comp_ind, age] <- age_hat[comp_ind, age] +
N_at_age[sp, sex, age, yr] * sel[flt, sex, age, yr_ind] *
index_q[flt, yr_ind] * exp(-(mo / 12.0) * Z_at_age[sp, sex, age, yr])
}
# age_hat[comp_ind, age] <- sum(N_at_age[sp, 1:nsex[sp], age, yr] * sel[flt, 1:nsex[sp], age, yr_ind] *
#                                 index_q[flt, yr_ind] * exp(-(mo / 12.0) * Z_at_age[sp, 1:nsex[sp], age, yr]))
}
if (flt_sex >= 1 && flt_sex <= 2) { # Sex-specific composition data
sex <- flt_sex
age_hat[comp_ind, age] <- N_at_age[sp, sex, age, yr] * sel[flt, sex, age, yr_ind] *
index_q[flt, yr_ind] * exp(-(mo / 12.0) * Z_at_age[sp, sex, age, yr])
}
if (flt_sex == 3) { # Joint composition data
for(sex in 1:nsex[sp]) {
age_hat[comp_ind, age + nages[sp] * (sex - 1)] <- N_at_age[sp, sex, age, yr] * sel[flt, sex, age, yr_ind] *
index_q[flt, yr_ind] * exp(-(mo / 12.0) * Z_at_age[sp, sex, age, yr])
}
}
}
}
# Adjustment for joint sex composition data
joint_adjust <- 1
if(flt_sex == 3){joint_adjust <- 2}
# Get true age comp
true_age_comp_hat[comp_ind, 1:(nages[sp] * joint_adjust)] <- age_hat[comp_ind, 1:(nages[sp] * joint_adjust)] / sum(age_hat[comp_ind, 1:(nages[sp] * joint_adjust)])
# Adjust for aging error
# - Combined or single-sex
age_obs_hat[comp_ind, 1:nages[sp]] <- age_hat[comp_ind, 1:nages[sp]] %*% age_error[sp, 1:nages[sp], 1:nages[sp]]
# # Adjust for aging error for
# - joint data
if(flt_sex == 3) {
age_obs_hat[comp_ind, (nages[sp] + 1):(nages[sp] * 2)] <- age_hat[comp_ind, (nages[sp] + 1):(nages[sp] * 2)] %*% age_error[sp, 1:nages[sp], 1:nages[sp]]
}
# Survey catch-at-age - standardize to sum to 1
if (comp_type == 0) {
comp_hat[comp_ind, ] <- age_obs_hat[comp_ind, ] / sum(age_obs_hat[comp_ind, ])
}
# Catch-at-length
if (comp_type == 1) {
sex <- 1
if(flt_sex > 0 & flt_sex < 3) {sex = flt_sex} # Adjust sex for males/females
# Convert from catch-at-age to catch-at-length
# - Combined or single-sex
comp_hat[comp_ind, 1:nlengths[sp]] <- age_obs_hat[comp_ind, 1:nages[sp]] %*% age_trans_matrix[flt_age_transition_index[flt], sex, 1:nages[sp], 1:nlengths[sp]]
# Convert from catch-at-age to catch-at-length for
# - joint comp data
if (flt_sex == 3) {
sex = 2
comp_hat[comp_ind, (nlengths[sp] + 1):(nlengths[sp] * 2)] <- age_obs_hat[comp_ind, (nages[sp] + 1):(nages[sp] * 2)] %*% age_trans_matrix[flt_age_transition_index[flt], sex, 1:nages[sp], 1:nlengths[sp]]
}
# Standardize to sum to 1
comp_hat[comp_ind, ] <- comp_hat[comp_ind, ] / sum(comp_hat[comp_ind, ])
}
}
comp_ind
# Extract indices
flt <- comp_ctl[comp_ind, 1]
sp <- comp_ctl[comp_ind, 2]
flt_sex <- comp_ctl[comp_ind, 3]
comp_type <- comp_ctl[comp_ind, 4]
yr <- comp_ctl[comp_ind, 5]
mo <- comp_n[comp_ind, 1]
# Year calculations
if(yr > 0) yr <- yr - styr + 1
if(yr < 0) yr <- -yr - styr + 1
# Determine year index for projections
yr_ind <- yr
if(yr > nyrs_hind) {yr_ind <- nyrs_hind}
nages[sp]
flt_type[flt]
flt_sex
nsex[sp]
age_hat[comp_ind, age] <- age_hat[comp_ind, age] +
F_flt_age[flt, sex, age, yr] / Z_at_age[sp, sex, age, yr] *
(1 - exp(-Z_at_age[sp, sex, age, yr])) * N_at_age[sp, sex, age, yr]
age_hat[comp_ind, age]
age
ncol(comp_obs)
comp_obs
load("~/Documents/GitHub/Rceattle/ss ebs comp minus1.RData")
params <- mod_objects$estimated_params
data_list <- rearrange_dat(mod_objects$data_list)
data_list$forecast <- c(0,0,0)
data_list$Ceq = rep(1,3)
data_list$avgnMode = 0
comp_obs <- data_list$comp_obs
comp_obs <- matrix(as.numeric(comp_obs), nrow = nrow(comp_obs), ncol = ncol(comp_obs))
head(comp_obs)
head(data_list$comp_obs)
# Grant Adams, Kirstin Holsman, Andre Punt - April 2019
# Code to run Bering Sea CEATTLE model in TMB
# Citation:
# Holsman, K. K., Ianelli, J., Aydin, K., Punt, A. E., and Moffitt, E. A. 2015. A comparison of fisheries biological reference points estimated from temperature-specific multi-species and single-species climate-enhanced stock assessment models. Deep-Sea Research Part II: Topical Studies in Oceanography, 134: 360–378.
library(Rceattle)
################################################
# Data
################################################
# Example
# To run the 2017 single species assessment for the Bering Sea, a data file must first be loaded:
data("BS2017SS") # Single-species data. ?BS2017SS for more information on the data
data("BS2017MS") # Multi-species data. Note: the only difference is the residual mortality (M1_base) is lower
# Write data to excel
Rceattle::write_data(data_list = BS2017SS, file = "BS2017SS.xlsx")
# Change the data how you want in excel
# Read the data back in
mydata <- Rceattle::read_data( file = "BS2017SS.xlsx")
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
mydata$fleet_control$Comp_loglike <- -1
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
# Grant Adams, Kirstin Holsman, Andre Punt - April 2019
# Code to run Bering Sea CEATTLE model in TMB
# Citation:
# Holsman, K. K., Ianelli, J., Aydin, K., Punt, A. E., and Moffitt, E. A. 2015. A comparison of fisheries biological reference points estimated from temperature-specific multi-species and single-species climate-enhanced stock assessment models. Deep-Sea Research Part II: Topical Studies in Oceanography, 134: 360–378.
library(Rceattle)
################################################
# Data
################################################
# Example
# To run the 2017 single species assessment for the Bering Sea, a data file must first be loaded:
data("BS2017SS") # Single-species data. ?BS2017SS for more information on the data
data("BS2017MS") # Multi-species data. Note: the only difference is the residual mortality (M1_base) is lower
# Write data to excel
Rceattle::write_data(data_list = BS2017SS, file = "BS2017SS.xlsx")
# Change the data how you want in excel
# Read the data back in
mydata <- Rceattle::read_data( file = "BS2017SS.xlsx")
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
mydata$fleet_control$Comp_loglike <- -1
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
?ADoverload
comp_ctl[comp_ind, 1]
# Grant Adams, Kirstin Holsman, Andre Punt - April 2019
# Code to run Bering Sea CEATTLE model in TMB
# Citation:
# Holsman, K. K., Ianelli, J., Aydin, K., Punt, A. E., and Moffitt, E. A. 2015. A comparison of fisheries biological reference points estimated from temperature-specific multi-species and single-species climate-enhanced stock assessment models. Deep-Sea Research Part II: Topical Studies in Oceanography, 134: 360–378.
library(Rceattle)
################################################
# Data
################################################
# Example
# To run the 2017 single species assessment for the Bering Sea, a data file must first be loaded:
data("BS2017SS") # Single-species data. ?BS2017SS for more information on the data
data("BS2017MS") # Multi-species data. Note: the only difference is the residual mortality (M1_base) is lower
# Write data to excel
Rceattle::write_data(data_list = BS2017SS, file = "BS2017SS.xlsx")
# Change the data how you want in excel
# Read the data back in
mydata <- Rceattle::read_data( file = "BS2017SS.xlsx")
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
mydata$fleet_control$Comp_loglike <- -1
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
# Grant Adams, Kirstin Holsman, Andre Punt - April 2019
# Code to run Bering Sea CEATTLE model in TMB
# Citation:
# Holsman, K. K., Ianelli, J., Aydin, K., Punt, A. E., and Moffitt, E. A. 2015. A comparison of fisheries biological reference points estimated from temperature-specific multi-species and single-species climate-enhanced stock assessment models. Deep-Sea Research Part II: Topical Studies in Oceanography, 134: 360–378.
library(Rceattle)
################################################
# Data
################################################
# Example
# To run the 2017 single species assessment for the Bering Sea, a data file must first be loaded:
data("BS2017SS") # Single-species data. ?BS2017SS for more information on the data
data("BS2017MS") # Multi-species data. Note: the only difference is the residual mortality (M1_base) is lower
# Write data to excel
Rceattle::write_data(data_list = BS2017SS, file = "BS2017SS.xlsx")
# Change the data how you want in excel
# Read the data back in
mydata <- Rceattle::read_data( file = "BS2017SS.xlsx")
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
mydata$fleet_control$Comp_loglike <- -1
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
