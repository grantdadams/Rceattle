if(HCR == 6) { # PFMC Category 1 HCR
F_results$proj_F[sp, yr] <- F_results$proj_F[sp, yr]
if(ssb[sp, yr-1] < rps_results$DynamicSB0[sp, yr-1] * Ptarget[sp]) {
F_results$proj_F[sp, yr] <- (Flimit[sp] + QnormHCR[sp]) * (rps_results$DynamicSB0[sp, yr-1] * Ptarget[sp] * (ssb[sp, yr-1] - rps_results$DynamicSB0[sp, yr-1] * Plimit[sp])) /
(ssb[sp, yr-1] * (rps_results$DynamicSB0[sp, yr-1] * (Ptarget[sp] - Plimit[sp])))
}
if(ssb[sp, yr-1] < rps_results$DynamicSB0[sp, yr-1] * Plimit[sp]) {
F_results$proj_F[sp, yr] <- 0.0
}
}
if(HCR == 7) { # SESSF Tier 1 HCR
F_results$proj_F[sp, yr] <- F_results$proj_F[sp, yr]
if(ssb[sp, yr-1] < rps_results$DynamicSB0[sp, yr-1] * Ptarget[sp]) {
F_results$proj_F[sp, yr] <- Ftarget[sp] * ((ssb[sp, yr-1]/(rps_results$DynamicSB0[sp, yr-1] * Plimit[sp]))-1)
}
if(ssb[sp, yr-1] < rps_results$DynamicSB0[sp, yr-1] * Plimit[sp]) {
F_results$proj_F[sp, yr] <- 0.0
}
}
}
# Set F to 0 if not forecast
if(forecast[sp] == 0) {
F_results$proj_F[sp, yr] <- 0.0
}
# Adjust F*selex
# -- 6.8.3. Update F for the projection (account for selectivity and fleets)
F_results$F_spp_age[sp,,, yr] <- 0.0
# -- Multiply F from HCR by selectivity and fleet proportion
F_results$F_spp[sp, yr] <- F_results$proj_F[sp, yr]
for(flt in 1:n_flt) {
if(sp == flt_spp[flt]) {
F_results$F_flt[sp, yr] <- proj_F_prop[flt] * F_results$proj_F[sp, yr]
for(age in 1:nages[sp]) {
for(sex in 1:nsex[sp]) {
F_results$F_flt_age[flt, sex, age, yr] <- sel[flt, sex, age, nyrs_hind] * proj_F_prop[flt] * F_results$proj_F[sp, yr] # FIXME using last year of selectivity
if(flt_type[flt] == 1) {
F_results$F_spp_age[sp, sex, age, yr] <- F_results$F_spp_age[sp, sex, age, yr] + F_results$F_flt_age[flt, sex, age, yr]
}
}
}
}
}
# -- 6.8.4. Update mortality for forecast
for(age in 1:nages[sp]) {
for(sex in 1:nsex[sp]) {
M_at_age[sp, sex, age, yr] <- M1_at_age[sp, sex, age] + M2_at_age[sp, sex, age, yr]
Z_at_age[sp, sex, age, yr] <- M1_at_age[sp, sex, age] + F_results$F_spp_age[sp, sex, age, yr] + M2_at_age[sp, sex, age, yr]
}
}
# ** 6.9. FORECAST NUMBERS AT AGE, BIOMASS-AT-AGE (kg), and SSB-AT-AGE (kg) ----
# -- 6.9.1. Forecasted recruitment
# - Option 1: Use mean rec
if((proj_mean_rec == 1) & (srr_pred_fun > 1)) {
R[sp, yr] <- exp(log(avg_R[sp]) + rec_dev[sp, yr]) # Projections use mean R given bias in R0
}
# - Mean rec and environment
if((proj_mean_rec == 1) & (srr_pred_fun < 2)) {
beta_rec_tmp <- beta_rec_pars[sp,]
env_rec_tmp <- env_index_srr[yr,]
srr_mult <- sum(env_rec_tmp * beta_rec_tmp)
R[sp, yr] <- exp(log(avg_R[sp]) + rec_dev[sp, yr]) * exp(srr_mult)
}
# - Option 2: Use SRR and rec devs
if(proj_mean_rec == 0) {
if(srr_pred_fun == 0) { # Random about mean (e.g. Alaska)
R[sp, yr] <- R0[sp] * exp(rec_dev[sp, yr])
}
if(srr_pred_fun == 1) { # Random about mean with environmental effects
beta_rec_tmp <- beta_rec_pars[sp,]
env_rec_tmp <- env_index_srr[yr,]
srr_mult <- sum(env_rec_tmp * beta_rec_tmp)
R[sp, yr] <- R0[sp] * exp(rec_dev[sp, yr] + srr_mult)
}
if(srr_pred_fun == 2) { # Beverton-Holt
R[sp, yr] <- exp(rec_pars[sp, 1]) * ssb[sp, yr-minage[sp]] * exp(rec_dev[sp, yr]) /
(1 + exp(rec_pars[sp, 2]) * ssb[sp, yr-minage[sp]])
}
if(srr_pred_fun == 3) { # Beverton-Holt with environmental impacts on alpha
beta_rec_tmp <- beta_rec_pars[sp,]
env_rec_tmp <- env_index_srr[yr,]
srr_mult <- sum(env_rec_tmp * beta_rec_tmp)
srr_alpha <- exp(rec_pars[sp, 1] + srr_mult)
R[sp, yr] <- srr_alpha * ssb[sp, yr-minage[sp]] * exp(rec_dev[sp, yr]) /
(1 + exp(rec_pars[sp, 2]) * ssb[sp, yr-minage[sp]])
}
if(srr_pred_fun == 4) { # Ricker
R[sp, yr] <- exp(rec_pars[sp, 1]) * ssb[sp, yr-minage[sp]] *
exp(-exp(rec_pars[sp, 2]) * ssb[sp, yr-minage[sp]]/1000000.0) * exp(rec_dev[sp, yr])
}
if(srr_pred_fun == 5) { # Ricker with environmental impacts on alpha
beta_rec_tmp <- beta_rec_pars[sp,]
env_rec_tmp <- env_index_srr[yr,]
srr_mult <- sum(env_rec_tmp * beta_rec_tmp)
srr_alpha <- exp(rec_pars[sp, 1] + srr_mult)
R[sp, yr] <- srr_alpha * ssb[sp, yr-minage[sp]] *
exp(-exp(rec_pars[sp, 2]) * ssb[sp, yr-minage[sp]]/1000000.0) * exp(rec_dev[sp, yr])
}
}
N_at_age[sp, 1, 1, yr] <- R[sp, yr] * R_sexr[sp]
if(nsex[sp] > 1){
N_at_age[sp, 2, 1, yr] <- R[sp, yr] * (1 - R_sexr[sp])
}
# -- Ages > recruitment
for(age in 1:nages[sp]) {
for(sex in 1:nsex[sp]) {
# if(estDynamics[sp] == 0) { # Estimated numbers-at-age
# -- Where age < plus group
if(age < nages[sp]) {
N_at_age[sp, sex, age + 1, yr] <- N_at_age[sp, sex, age, yr - 1] * exp(-Z_at_age[sp, sex, age, yr-1])
}
# -- Plus group
if(age == nages[sp]) {
N_at_age[sp, sex, age, yr] <- N_at_age[sp, sex, age - 1, yr - 1] * exp(-Z_at_age[sp, sex, age-1, yr-1]) +
N_at_age[sp, sex, age, yr - 1] * exp(-Z_at_age[sp, sex, age, yr-1])
}
# } else if(estDynamics[sp] == 1) { # Fixed numbers-at-age - fixed scalar
#   N_at_age[sp, sex, age, yr] <- pop_scalar[sp, 1] * NByageFixed[sp, sex, age, yr]
# } else if(estDynamics[sp] == 2) { # Fixed numbers-at-age age-independent scalar
#   N_at_age[sp, sex, age, yr] <- pop_scalar[sp, 1] * NByageFixed[sp, sex, age, yr]
# } else if(estDynamics[sp] == 3) { # Fixed numbers-at-age age-dependent scalar
#   N_at_age[sp, sex, age, yr] <- pop_scalar[sp, age] * NByageFixed[sp, sex, age, yr]
# } else {
#   stop("Invalid 'estDynamics'")
# }
# Constraint to reduce population collapse
# pos_tmp <- posfun(N_at_age[sp, sex, age, yr], 0.001)
# N_at_age[sp, sex, age, yr] <- pos_tmp$ans
# zero_N_pen[sp] <- zero_N_pen[sp] + pos_tmp$penalty
# -- 6.9.4. FORECAST ssb BY AGE
biomass_at_age[sp, sex, age, yr] <- N_at_age[sp, sex, age, yr] * wt[pop_wt_index[sp], sex, age, nyrs_hind] # 6.5.
biomass[sp, yr] <- biomass[sp, yr] + biomass_at_age[sp, sex, age, yr]
} # End sex loop
# -- 6.9.5. FORECAST ssb (SUM ACROSS AGES)
ssb_at_age[sp, age, yr] <- N_at_age[sp, 1, age, yr] *
exp(-Z_at_age[sp, 1, age, yr] * (spawn_month[sp]/12.0)) *
wt[ssb_wt_index[sp], 1, age, nyrs_hind] * pmature_sexr[sp, age] # 6.6.
ssb[sp, yr] <- ssb[sp, yr] + ssb_at_age[sp, age, yr]
}
}
}
# * 6.10. ESTIMATE AVERAGE NUMBERS AT AGE ----
avgN_at_age <- switch(
avgnMode+1,
# Case 0: MSVPA approach
{
N_at_age *
(1 - exp(-Z_at_age)) / Z_at_age
},
# Case 1: Kinzey and Punt (2009) approximation
{
N_at_age *
exp(-Z_at_age / 2)
},
# Case 2: Van Kirk et al (2010) approximation
{
N_at_age
},
# Default case
{
stop("Invalid 'avgnMode'")
}
)
avgN_at_age[is.nan(avgN_at_age)] <- 0 # Divide by 0 for ages not represented
#TEST
# sum(N_at_age[1,1,,1:39] - mod_objects$quantities$N_at_age[1,1,,1:39])
# sum(avgN_at_age[,1,,] - mod_objects$quantities$avgN_at_age[,1,,])
# ------------------------------------------------------------------------- #
# 7. RATION AND DIET ----
# ------------------------------------------------------------------------- #
# * 7.1. Calculate ration ----
ration <- calculate_ration(nspp, nyrs, max_nsex, max_nages, nyrs_hind, Ceq, Qc, Tcm, Tco, Tcl,
CK1, CK4, CA, CB, fday, env_index, Cindex,
wt, pop_wt_index, Pvalue, Pyrs, nsex, nages)
#TEST
#sum(ration[1,1,,1:39] - mod_objects$quantities$ration[1,1,,1:39])
# * 7.2. Reorganize stomach content ----
diet_prop <- reorganize_stomach_content(stom_prop_obs, stom_prop_ctl, minage, nspp,
nyrs, nsex, nages, max_nsex, max_nages, nyrs_hind, styr)
#TEST
#sum(diet_prop[1,1,,1,1,,1:39] - mod_objects$quantities$diet_prop[1,1,,,1:39])
# * 7.3. Calculate other food stomach content ----
other_food_diet_prop <- calculate_other_food_diet_prop(nyrs, nspp, nsex, nages, max_nsex, max_nages,
diet_prop, other_food)
# ------------------------------------------------------------------------- #
# 8. START PREDATION ----
# ------------------------------------------------------------------------- #
if (msmMode > 0) {
# ------------------------------------------------------------------------- #
# * 8.1. SUITABILITY EQUATIONS ----
# ------------------------------------------------------------------------- #
# 8.1.1. Holsman and MSVPA based suitability # FIXME - not flexible for interannual variation
if (suitMode == 0) {
suit_list <- calculate_MSVPA_suitability(diet_prop, avgN_at_age, wt, pop_wt_index,
other_food_diet_prop, nspp, nsex, max_nsex, nages, max_nages, nyrs,
nyrs_hind, suit_styr, suit_endyr, nyrs_suit,
msmMode)
#TEST
#sum(suit_list$suit_main[1,1,,1,1,,1:39] - mod_objects$quantities$suit_main[1,1,,,1:39])
#TEST
#sum(suit_list$suit_other[,1,,] - mod_objects$quantities$suit_other[,1,,])
}
# 8.1.2. GAMMA suitability
if(suitMode %in% c(1,2)){
suit_list <- calculate_gamma_suitability(nspp, nages, nsex, nyrs, nyrs_hind,
max_nages, max_nsex,
laa, wt, pop_wt_index, vulnerability,
vulnerability_other, gam_a, gam_b, suitMode)
}
# 8.1.3. Lognormal suitability
if(suitMode %in% c(3,4)){
suit_list <- calculate_lognormal_suitability(nspp, nages, nsex, nyrs, nyrs_hind,
max_nages, max_nsex,
laa, wt, pop_wt_index, vulnerability,
vulnerability_other, gam_a, gam_b, suitMode)
}
# ------------------------------------------------------------------------- #
# * 8.2. PREDATION MORTALITY EQUATIONS ----
# ------------------------------------------------------------------------- #
# -- 8.2.1. MSVPA PREDATION MORTALITY
if ((msmMode == 1) | (msmMode == 2)) {
predation_results <- calculate_predation(nspp, nsex, nages, nyrs, nyrs_hind,
max_nages, max_nsex,
avgN_at_age, suit_list$suit_main, suit_list$suit_other, other_food,
wt, pop_wt_index, ration, msmMode)
# Update M2 array
M2_at_age <- predation_results$M2_at_age
#TEST
#sum(M2_at_age[,1,,] - mod_objects$quantities$M2_at_age[,1,,])
}
} # Predation loop
} # Population dynamics loop (niter)
# ------------------------------------------------------------------------- #
# 8. ENDS PREDATION AND POPULATION DYNAMICS LOOPS ----
# ------------------------------------------------------------------------- #
# ------------------------------------------------------------------------- #
# 9. INDEX EQUATIONS ----
# ------------------------------------------------------------------------- #
# * 9.1. Index of abundance/biomass ----
index_hat <- calculate_abundance_index(index_ctl, index_n, N_at_age, Z_at_age, sel,
wt, flt_units, flt_wt_index, nages, nsex,
nyrs_hind, styr)
# * 9.2. Analytical survey q following Ludwig and Martell 1994 ----
index_q_analytical <- calculate_analytical_q(index_ctl, index_n, index_obs, index_hat,
est_sigma_index, est_index_q, n_flt, nyrs_hind, styr)
for(index in 1:n_flt) {
# Set index_q to analytical if used
if(est_index_q[index] == 3 & flt_type[index] == 2) {
index_q[index, ] <- rep(index_q_analytical[index], nyrs_hind)
}
}
# * 9.3. Survey Biomass - multiply by q ----
# - Extract necessary columns for vectorized operations
indices <- index_ctl[, 1]       # Temporary survey indices (1-based)
flt_yrs <- index_ctl[, 3]       # Temporary index for years of data
# - Adjust flt_yrs
flt_yrs[flt_yrs > 0] <- flt_yrs[flt_yrs > 0] - styr + 1
flt_yrs[flt_yrs < 0] <- -flt_yrs[flt_yrs < 0] - styr + 1
# - Determine yr_ind based on flt_yrs
yr_inds <- flt_yrs
yr_inds[flt_yrs > nyrs_hind] <- nyrs_hind
# - Ensure indices are within valid bounds
valid_indices <- indices > 0 & indices <= ncol(index_q) & yr_inds > 0 & yr_inds <= nyrs_hind
# - Update index_hat only for valid indices
index_hat[valid_indices] <- index_q[cbind(indices[valid_indices], yr_inds[valid_indices])] * index_hat[valid_indices]
# - Optionally, handle cases where indices were out of bounds
if (any(!valid_indices)) {
warning("Some indices were out of bounds.")
}
# * 9.4. Calculate analytical sigma following Ludwig and Walters 1994 ----
ln_index_analytical_sd <- calculate_analytical_sd(index_ctl, index_obs, index_hat, n_flt, nyrs_hind, styr)
#TEST
#sum(abs(index_hat - mod_objects$quantities$index_hat))
# ------------------------------------------------------------------------- #
# 10. FISHERY EQUATIONS  ----
# ------------------------------------------------------------------------- #
# * 10.1. ESTIMATE CATCH ----
catch_hat <- estimate_catch(catch_ctl, catch_n, F_results$F_flt_age, Z_at_age, N_at_age,
wt, sel, flt_wt_index, proj_F_prop, flt_units,
nsex, nages, styr, nyrs_hind)
#TEST
#sum(abs(catch_hat - mod_objects$quantities$catch_hat))
# * 10.2 Exploitable biomass ----
exploitable_biomass <- calculate_exploitable_biomass(n_flt, flt_spp, flt_type, nyrs, nyrs_hind,
nages, nsex, N_at_age, wt, sel,
flt_wt_index, proj_F_prop)
# ------------------------------------------------------------------------- #
# 11. COMPOSITION EQUATIONS ----
# ------------------------------------------------------------------------- #
comp_hat <- estimate_comp(comp_ctl, comp_n, comp_obs, F_results$F_flt_age, Z_at_age, N_at_age,
sel, index_q, age_error, age_trans_matrix,
flt_type, nages, nlengths, nsex, styr,
nyrs_hind, flt_age_transition_index)
#TEST
#sum(abs(comp_hat - mod_objects$quantities$comp_hat))
# ------------------------------------------------------------------------- #
# 12. ESTIMATED DIET ----
# ------------------------------------------------------------------------- #
#TODO
# ------------------------------------------------------------------------- #
# 13. DERIVED QUANTITIES ----
# ------------------------------------------------------------------------- #
# 13.1. Depletion
biomass_depletion <- matrix(0, nrow = nspp, ncol = nyrs)
ssb_depletion <- matrix(0, nrow = nspp, ncol = nyrs)
for(sp in 1:nspp) {
for(yr in 1:nyrs) {
if(DynamicHCR == 0) {
biomass_depletion[sp, yr] <- biomass[sp, yr] / rps_results$B0[sp, nyrs]  # Corrected index
ssb_depletion[sp, yr] <- ssb[sp, yr] / rps_results$SB0[sp, nyrs]        # Corrected index
}
if(DynamicHCR == 1) {
biomass_depletion[sp, yr] <- biomass[sp, yr] / rps_results$DynamicB0[sp, yr]
ssb_depletion[sp, yr] <- ssb[sp, yr] / rps_results$DynamicSB0[sp, yr]
}
# Multi-species and no HCR (MSSB0 is input otherwise)
if(HCR == 0 && msmMode > 0) {
biomass_depletion[sp, yr] <- biomass[sp, yr] / biomass[sp, nyrs]  # Corrected index
ssb_depletion[sp, yr] <- ssb[sp, yr] / ssb[sp, nyrs]              # Corrected index
}
}
}
RTMB::REPORT(biomass_depletion)
RTMB::REPORT(ssb_depletion)
# ------------------------------------------------------------------------- #
# 14. LIKELIHOOD EQUATIONS ----
# ------------------------------------------------------------------------- #
# 14.0. OBJECTIVE FUNCTION
jnll_comp = matrix(0, 19, n_flt) # matrix of negative log-likelihood components
# -- Data likelihood components
# Slot 0 -- Survey biomass
# Slot 1 -- Total catch (kg)
# Slot 2 -- Age/length composition
# Slot 3 -- Sex ratio likelihood TODO
# Slot 4 -- Selectivity
# Slot 5 -- Selectivity annual deviates
# Slot 6 -- Survey selectivity normalization
# Slot 7 -- Survey catchability prior
# Slot 8 -- Survey catchability annual deviates
# -- Priors/penalties
# Slot 9 -- Stock recruitment parameter (alpha) prior
# Slot 10 -- Tau -- Annual recruitment deviation
# Slot 11 -- init_dev -- Initial abundance-at-age
# Slot 12 -- Epsilon -- Annual fishing mortality deviation
# Slot 13 -- SPR penalities
# Slot 14 -- N-at-age < 0 penalty
# Slot 15 -- M_at_age prior
# -- M2_at_age likelihood components
# Slot 16 -- Ration likelihood
# Slot 17 -- Ration penalties
# Slot 18 -- Diet proportion by weight likelihood
# * 14.1. INDEX DATA ----
jnll_comp <- calculate_index_nll(index_obs, index_ctl, est_sigma_index, index_ln_sd,
ln_index_analytical_sd, jnll_comp,
index_hat, flt_type, endyr)
# * 14.2. CATCH DATA ----
jnll_comp <- calculate_catch_nll(catch_obs, catch_ctl, catch_hat, catch_ln_sd,
est_sigma_fsh, jnll_comp,
F_dev, flt_type, styr, endyr)
# * 14.3. COMPOSITION DATA ----
jnll_comp <- calculate_comp_nll(comp_obs, comp_hat, comp_ctl, comp_n, nages, nlengths,
DM_pars, flt_type, comp_ll_type, comp_weights, jnll_comp, endyr)
comp_obs - mod_objects$quantities$comp_obs
mod_objects$quantities$jnll_comp
sum(abs(comp_hat - mod_objects$quantities$comp_hat))
# * 14.5. SELECTIVITY ----
jnll_comp <- calculate_selectivity_nll(n_flt, flt_spp, flt_type, flt_sel_type, flt_varying_sel,
non_par_sel, sel_curve_pen, avg_sel, sel_inf_dev,
ln_sel_slp_dev, sel_dev_sd, flt_nselages, nsex, nages,
nyrs_hind, jnll_comp)
# * 14.5. CATCHABILITY ----
jnll_comp <- calculate_catchability_nll(n_flt, nyrs_hind, est_index_q, index_varying_q,
flt_type, index_ln_q, index_ln_q_prior,
index_q_sd, index_q_dev, index_q_dev_sd,
env_index, rho_trans, jnll_comp)
# * 14.6. RECRUITMENT ----
jnll_comp <- calculate_recruitment_nll(nspp, srr_est_mode, srr_pred_fun, steepness, srr_prior,
srr_prior_sd, rec_pars, Bmsy_lim, initMode, nages,
init_dev, rec_dev, R_sd, R, R_hat, srr_fun,
srr_hat_styr, srr_hat_endyr, nyrs_hind, jnll_comp)
# * 14.7. MORTALITY ----
jnll_comp <- calculate_mortality_nll(nspp, nsex, nages, nyrs, M1_model, M1_use_prior, M2_use_prior,
M1_at_age, M_at_age, M_prior, M_prior_sd, jnll_comp)
jnll = sum(jnll_comp)
#TEST
#round(jnll_comp - mod_objects$quantities$jnll_comp,4)
# ------------------------------------------------------------------------- #
# 15. REPORT SECTION ----
# ------------------------------------------------------------------------- #
RTMB::REPORT(ssb)
RTMB::REPORT(biomass)
RTMB::REPORT(R)
RTMB::REPORT(jnll_comp)
RTMB::REPORT(comp_hat)
RTMB::REPORT(jnll)
return(jnll)
}
source("~/Documents/GitHub/Rceattle/R/dev/rtmb dev.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
# Step 2 -  Seperate survey biomass info from observation ----
data_list$index_ctl <- data_list$index_data[,c("Fleet_code", "Species", "Year")]
data_list$index_ctl
sapply(data_list$index_ctl, as.integer)
sapply(data_list$index_ctl, as.integer)
data_list$index_ctl
sapply(data_list$index_ctl, as.integer)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
# Step 5 -  Seperate uobs info from observation ----
data_list$stom_prop_ctl <- sapply(data_list$stom_prop_data[,c("Pred", "Prey", "Pred_sex", "Prey_sex", "Pred_age", "Prey_age", "Year")], as.integer)
data_list$stom_prop_ctl
class(data_list$stom_prop_ctl)
class(data_list$stom_prop_data[,c("Pred", "Prey", "Pred_sex", "Prey_sex", "Pred_age", "Prey_age", "Year")])
# Step 5 -  Seperate uobs info from observation ----
data_list$stom_prop_ctl <- as.matrix(sapply(data_list$stom_prop_data[,c("Pred", "Prey", "Pred_sex", "Prey_sex", "Pred_age", "Prey_age", "Year")], as.integer))
class(data_list$stom_prop_ctl)
data_list$stom_prop_ctl
# Step 5 -  Seperate uobs info from observation ----
data_list$stom_prop_ctl <- apply(data_list$stom_prop_data[,c("Pred", "Prey", "Pred_sex", "Prey_sex", "Pred_age", "Prey_age", "Year")], 2, as.integer)
data_list$stom_prop_ctl
class(data_list$stom_prop_ctl)
?apply
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
integer(1)
integer(2)
as.integer()
as.integer(1)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
r_sexes
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
source("~/Documents/GitHub/Rceattle/R/0-ceattle_equations_v11.R", echo=TRUE)
# Grant Adams, Kirstin Holsman, Andre Punt - April 2019
# Code to run Bering Sea CEATTLE model in TMB
# Citation:
# Holsman, K. K., Ianelli, J., Aydin, K., Punt, A. E., and Moffitt, E. A. 2015. A comparison of fisheries biological reference points estimated from temperature-specific multi-species and single-species climate-enhanced stock assessment models. Deep-Sea Research Part II: Topical Studies in Oceanography, 134: 360–378.
library(Rceattle)
################################################
# Data
################################################
# Example
# To run the 2017 single species assessment for the Bering Sea, a data file must first be loaded:
data("BS2017SS") # Single-species data. ?BS2017SS for more information on the data
data("BS2017MS") # Multi-species data. Note: the only difference is the residual mortality (M1_base) is lower
# Write data to excel
Rceattle::write_data(data_list = BS2017SS, file = "BS2017SS.xlsx")
# Change the data how you want in excel
# Read the data back in
mydata <- Rceattle::read_data( file = "BS2017SS.xlsx")
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
mydata$fleet_control$Comp_loglike <- -1
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
# Single-species, but estimate M
ss_run_M <- Rceattle::fit_mod(data_list = mydata,
inits = ss_run$estimated_params, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
M1Fun = build_M1(M1_model = 1,
M1_use_prior = FALSE,
M2_use_prior = FALSE),
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
plot_biomass(ss_run_M, add_ci = TRUE)
# - Multi-species
# For the a multispecies model we from the single species parameters.
ms_run <- Rceattle::fit_mod(data_list = BS2017MS,
inits = ss_run$estimated_params, # Initial parameters from single species ests
M1Fun = build_M1(M1_model = 1,
updateM1 = TRUE,
M1_use_prior = FALSE,
M2_use_prior = FALSE),
file = NULL, # Don't save
estimateMode = 0, # Estimate
niter = 1, # 3 iterations around population and predation dynamics
random_rec = FALSE, # No random recruitment
msmMode = 1, # MSVPA based
suitMode = 0, # empirical suitability
verbose = 1)
