comp_obs[flt_accum_age_upper + nages] =  comp_obs[flt_accum_age_upper + nages] + comp_obs[age]
comp_obs[age] = 0
}
}
comp_obs
nages = 10
comp_obs = 1:10
flt_accum_age_lower = 1
flt_accum_age_upper = 10
comp_obs
flt_accum_age_upper
age = 10
age_test < flt_accum_age_lower
age_test = age
if(age >= nages){
age_test = age - nages
}
age_test < flt_accum_age_lower
age_test
nages
nages
age > nages
nages = 10
comp_obs = 1:10
flt_accum_age_lower = 1
flt_accum_age_upper = 10
#Accumulation age
for(age in 1:nages){
age_test = age
if(age > nages){
age_test = age - nages
}
# Lower
if(age_test < flt_accum_age_lower){
comp_obs[flt_accum_age_lower + nages] =  comp_obs[flt_accum_age_lower + nages] + comp_obs[age]
comp_obs[age] = 0
}
# Upper
if(age_test > flt_accum_age_upper){
comp_obs[flt_accum_age_upper + nages] =  comp_obs[flt_accum_age_upper + nages] + comp_obs[age]
comp_obs[age] = 0
}
}
comp_obs
library(Rceattle)
library(Rceattle)
# -- NPFMC Tier 3
data("GOA2018SS")
data("BS2017SS")
# SS M
ss_run_M3 <- Rceattle::fit_mod(data_list = BS2017SS,
inits = NULL, # Initial parameters from ss_run_M
estimateMode = 0, # Run projection only
M1Fun = build_M1(M1_model = c(1,1,1),
M1_use_prior = FALSE,
M2_use_prior = FALSE),
msmMode = 0, # Single species mode
phase = "default",
initMode = 1,
verbose = 1)
load("~/GitHub/Rceattle/m2.rdata")
ss_run_M2$quantities$comp_obs[1,]
ss_run_M3$quantities$comp_obs[1,]
sum(ss_run_M2$quantities$comp_obs[1,10:12])
sum(ss_run_M2$quantities$comp_obs[1,])
sum(ss_run_M2$quantities$comp_obs[1,], na.rm = TRUE)
sum(ss_run_M3$quantities$comp_obs[1,], na.rm = TRUE)
sum(ss_run_M3$quantities$joint_adjust[1,], na.rm = TRUE)
sum(ss_run_M3$quantities$joint_adjust, na.rm = TRUE)
length(ss_run_M3$quantities$joint_adjust, na.rm = TRUE)
length(ss_run_M3$quantities$joint_adjust)
ss_run_M3$flt_accum_age_upper
library(Rceattle)
library(Rceattle)
# -- NPFMC Tier 3
data("GOA2018SS")
data("BS2017SS")
# SS M
ss_run_M3 <- Rceattle::fit_mod(data_list = BS2017SS,
inits = NULL, # Initial parameters from ss_run_M
estimateMode = 0, # Run projection only
M1Fun = build_M1(M1_model = c(1,1,1),
M1_use_prior = FALSE,
M2_use_prior = FALSE),
msmMode = 0, # Single species mode
phase = "default",
initMode = 1,
verbose = 1)
# Check rows sum to 1 on matrix mult
check <- rearrange_dat(BS2017SS)
check$comp_obs[1,]
ss_run_M3$quantities$comp_obs[1,]
sum(check$comp_obs[1,10:12])
ss_run_M3$quantities$comp_obs[1,10]
load("~/GitHub/Rceattle/m2.rdata")
ss_run_M2$quantities$comp_obs[1,]
ss_run_M3$quantities$comp_obs[1,]
ss_run_M2$quantities$comp_obs[1,]
round(ss_run_M3$quantities$comp_obs[1,],4)
round(ss_run_M2$quantities$comp_obs[1,],4)
library(Rceattle)
library(Rceattle)
# -- NPFMC Tier 3
data("GOA2018SS")
data("BS2017SS")
# SS M
ss_run_M3 <- Rceattle::fit_mod(data_list = BS2017SS,
inits = NULL, # Initial parameters from ss_run_M
estimateMode = 0, # Run projection only
M1Fun = build_M1(M1_model = c(1,1,1),
M1_use_prior = FALSE,
M2_use_prior = FALSE),
msmMode = 0, # Single species mode
phase = "default",
initMode = 1,
verbose = 1)
# Check rows sum to 1 on matrix mult
check <- rearrange_dat(BS2017SS)
check$comp_obs[1,]
oad("~/GitHub/Rceattle/m2.rdata")
round(ss_run_M3$quantities$comp_obs[1,],4)
round(ss_run_M2$quantities$comp_obs[1,],4)
load("~/GitHub/Rceattle/m2.rdata")
round(ss_run_M3$quantities$comp_obs[1,],4)
round(ss_run_M2$quantities$comp_obs[1,],4)
sum(check$comp_obs[1,10:12])
ss_run_M3$quantities$comp_obs[1,10]
library(Rceattle)
# -- NPFMC Tier 3
data("GOA2018SS")
data("BS2017SS")
# SS M
ss_run_M <- Rceattle::fit_mod(data_list = BS2017SS,
inits = NULL, # Initial parameters from ss_run_M
estimateMode = 0, # Run projection only
M1Fun = build_M1(M1_model = c(1,1,1),
M1_use_prior = FALSE,
M2_use_prior = FALSE),
msmMode = 0, # Single species mode
phase = "default",
initMode = 1,
verbose = 1)
# Ratio of F across Pcod fleets
avg_F <- (exp(ss_run_M$estimated_params$ln_mean_F+ss_run_M$estimated_params$F_dev)) # Average F from last 2 years
avg_F <- rowMeans(avg_F[,(ncol(avg_F)-2) : ncol(avg_F)])
f_ratio <- avg_F[14:16]
f_ratio <- f_ratio/sum(f_ratio)
# Adjust future F proportion to each fleet
ss_run_M$data_list$fleet_control$proj_F_prop <- rep(1,7)# <- c(rep(0, 7), 1,0,0,1, 0,0, f_ratio)
# Tier 3
ss_run_M_Tier3 <- Rceattle::fit_mod(data_list = ss_run_M$data_list,
inits = ss_run_M$estimated_params, # Initial parameters from ss_run_M
estimateMode = 0, # Run projection only
M1Fun = build_M1(M1_model = c(1,1,1),
M1_use_prior = FALSE,
M2_use_prior = FALSE),
HCR = build_hcr(HCR = 5, # Tier3 HCR
FsprTarget = 0.4, # F40%
FsprLimit = 0.35, # F35%
Plimit = c(0.2, 0, 0.2), # No fishing when SB<SB20
Alpha = 0.05),
msmMode = 0, # Single species mode
initMode = 1,
verbose = 1)
om <- em <- ss_run_M_Tier3
# - Simulate index and comp data and updatae EM
sim_dat <- sim_mod(om, simulate = FALSE)
em$data_list$srv_biom <- sim_dat$srv_biom
em$data_list$comp_data <- sim_dat$comp_data
# Restimate
em <- fit_mod(
data_list = em$data_list,
inits = em$estimated_params,
map =  NULL,
bounds = NULL,
file = NULL,
estimateMode = ifelse(em$data_list$estimateMode < 3, 0, em$data_list$estimateMode), # Run hindcast and projection, otherwise debug
HCR = build_hcr(HCR = em$data_list$HCR, # Tier3 HCR
DynamicHCR = em$data_list$DynamicHCR,
FsprTarget = em$data_list$FsprTarget,
FsprLimit = em$data_list$FsprLimit,
Ptarget = em$data_list$Ptarget,
Plimit = em$data_list$Plimit,
Alpha = em$data_list$Alpha,
Pstar = em$data_list$Pstar,
Sigma = em$data_list$Sigma
),
recFun = build_srr(srr_fun = em$data_list$srr_fun,
srr_pred_fun  = em$data_list$srr_pred_fun ,
proj_mean_rec  = em$data_list$proj_mean_rec ,
srr_est_mode  = em$data_list$srr_est_mode ,
srr_prior_mean  = em$data_list$srr_prior_mean,
srr_prior_sd   = em$data_list$srr_prior_sd ),
M1Fun =     build_M1(M1_model= em$data_list$M1_model,
updateM1 = FALSE,
M1_use_prior = em$data_list$M1_use_prior,
M2_use_prior = em$data_list$M2_use_prior,
M1_prior_mean = em$data_list$M1_prior_mean,
M1_prior_sd = em$data_list$M1_prior_sd),
random_rec = em$data_list$random_rec,
niter = em$data_list$niter,
msmMode = em$data_list$msmMode,
avgnMode = em$data_list$avgnMode,
minNByage = em$data_list$minNByage,
suitMode = em$data_list$suitMode,
initMode = em$data_list$initMode,
phase = NULL,
loopnum = 3,
getsd = FALSE,
verbose = 0)
plot_biomass(list(om, em))
plot_recruitment(list(om, em))
plot_index(list(om, em))
em$quantities$M1[,,1]/om$quantities$M1[,,1]
check <- data.frame(Parname = names(om$estimated_params), Off = length(names(om$estimated_params)))
for(i in 1:length(om$estimated_params)){
check[i,2] <- sum(om$estimated_params[[i]] != em$estimated_params[[i]], na.rm = TRUE)
}
check2 <- data.frame(Parname = names(om$data_list), Off = length(names(om$data_list)))
for(i in 1:length(om$data_list)){
check2[i,2] <- sum(om$data_list[[i]] != em$data_list[[i]], na.rm = TRUE)
}
# Maybe init mode is the problem
#FIXME at initialF to mapped out paramters in MSE function
# Run test MSE and check M
mse <- mse_run_parallel(om = om, em = em, nsim = 1, assessment_period = 1, sampling_period = 1, simulate_data = FALSE, sample_rec = FALSE, dir = NULL, file = NULL)
mod_list <- c(mse[[1]]$EM,list(mse[[1]]$OM))
plot_biomass(mod_list)
Mort <- sapply(mod_list, function(x) x$quantities$M[,1,1,1])
Year = 2017:2050
species = c("Pollock", "ATF", "Cod")
par(mfrow = c(3,1))
for(k in 1:3){
plot(y = Mort[k,-ncol(Mort)], x = Year, type = "l", main = species[k], ylab = "Mortality", ylim = range(Mort[k,]))
abline(h = Mort[k,ncol(Mort)], lty = 2)
legend("topright", c("EM", "OM"), lty = c(1,2), bty = "n")
}
em$quantities$M1[,1,1]/om$quantities$M1[,1,1]
mod_list[[33]]$quantities$M1[,1,1]/om$quantities$M1[,1,1]
# -- NPFMC Tier 3
data("GOA2018SS")
GOA2018SS$fleet_control
library(Rceattle)
library(Rceattle)
library(dplyr)
################################################
# Data
################################################
# Example
# To run the 2017 single species assessment for the Bering Sea, a data file must first be loaded:
data(BS2017SS) # ?BS2017SS for more information on the data
BS2017SS$projyr <- 2060
data("BS2017MS") # Note: the only difference is the residual mortality (M1_base) is lower
BS2017MS$projyr <- 2060
BS2017SS$fleet_control$proj_F_prop <-rep(1,7)
BS2017MS$fleet_control$proj_F_prop <- rep(1, 7)
################################################
# Estimate OMs
################################################
ss_run <- Rceattle::fit_mod(data_list = BS2017SS,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 1, # Estimate hindcast only
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = "default",
verbose = 1)
################################################
# EMs: Fixed M w/ harvest control rules
################################################
# -- Avg F
avg_F <- (exp(ss_run$estimated_params$ln_mean_F+ss_run$estimated_params$F_dev)) # Average F from last 5 years
avg_F <- rowMeans(avg_F[,(ncol(avg_F)-4) : ncol(avg_F)])[1:3]
ss_run_AvgF <- fit_mod(data_list = BS2017SS,
inits = ss_run$estimated_params, # Initial parameters from ss_run_M
estimateMode = 2, # Run projection only
HCR = build_hcr(HCR = 2, # Input F
FsprTarget = avg_F, # F40%
FsprLimit = 0.35,
Plimit = 0.2
),
msmMode = 0, # Single species mode
verbose = 1)
ss_run_AvgF <- fit_mod(data_list = BS2017SS,
inits = NULL, # Initial parameters from ss_run_M
estimateMode = 0, # Run projection only
HCR = build_hcr(HCR = 2, # Input F
FsprTarget = avg_F, # F40%
FsprLimit = 0.35,
Plimit = 0.2
),
msmMode = 0, # Single species mode
verbose = 1)
data_list = NULL;
inits = NULL;
map = NULL;
bounds = NULL;
file = NULL;
estimateMode = 0;
random_rec = FALSE;
random_q = FALSE;
random_sel = FALSE;
HCR = build_hcr();
niter = 3;
msmMode = 0;
avgnMode = 0;
initMode = 1
updateM1 = TRUE;
minNByage = 0;
suitMode = 0;
meanyr = NULL;
phase = NULL;
getsd = TRUE;
use_gradient = TRUE;
rel_tol = 1;
control = list(eval.max = 1e+09,
iter.max = 1e+09, trace = 0);
getJointPrecision = TRUE;
loopnum = 5;
verbose = 1;
newtonsteps = 0
recFun = build_srr()
M1Fun = build_M1()
projection_uncertainty = TRUE
data_list = BS2017SS
inits = ss_run$estimated_params
estimateMode = 0
HCR = build_hcr(HCR = 2, # Input F
FsprTarget = avg_F, # F40%
FsprLimit = 0.35,
Plimit = 0.2
)
msmMode = 0
verbose = 1
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 0 - Start ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
start_time <- Sys.time()
extend_length <- function(x){
if(length(x) == data_list$nspp){ return(x)}
else {return(rep(x, data_list$nspp))}
}
setwd(getwd())
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 1 - Load data ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.null(data_list)) {
stop("Missing data_list object")
}
data_list <- Rceattle::clean_data(data_list)
# Switches
data_list$random_rec <- as.numeric(random_rec)
data_list$estimateMode <- estimateMode
data_list$niter <- niter
data_list$avgnMode <- avgnMode
if(is.null(data_list$initMode)){
data_list$initMode <- initMode
}
data_list$msmMode <- msmMode
data_list$suitMode <- as.numeric(suitMode)
data_list$minNByage <- as.numeric(minNByage)
if(is.null(meanyr) & is.null(data_list$meanyr)){ # If no meanyear is provided in data or function, use end year
data_list$meanyr <- data_list$endyr
}
if(!is.null(meanyr)){ # If mean year is provided in function, override data
data_list$meanyr <- meanyr
}
# Recruitment switches
data_list$srr_fun <- recFun$srr_fun
data_list$srr_pred_fun <- recFun$srr_pred_fun
data_list$proj_mean_rec <- recFun$proj_mean_rec
data_list$srr_est_mode <- recFun$srr_est_mode
data_list$srr_prior_mean <- extend_length(recFun$srr_prior_mean)
data_list$srr_prior_sd <- extend_length(recFun$srr_prior_sd)
# M1
if(is.null(data_list$M1_model)){
data_list$M1_model= extend_length(M1Fun$M1_model)
}
# FIXME: may want to pull from data here too
updateM1 = M1Fun$updateM1
data_list$M1_use_prior = extend_length(M1Fun$M1_use_prior) * (data_list$M1_model > 0) # Sets to 0 if M1 is fixed
data_list$M2_use_prior = extend_length(M1Fun$M2_use_prior) * (msmMode > 0) # Sets to 0 if single-species
data_list$M1_prior_mean = extend_length(M1Fun$M1_prior_mean)
data_list$M1_prior_sd = extend_length(M1Fun$M1_prior_sd)
# HCR Switches (make length of nspp if not)
data_list$HCR = HCR$HCR
data_list$DynamicHCR = HCR$DynamicHCR
if(HCR$HCR != 2){ # FsprTarget is also used for fixed F (so may be of length nflts)
data_list$FsprTarget = extend_length(HCR$FsprTarget)
} else {
data_list$FsprTarget = HCR$FsprTarget
}
data_list$FsprLimit = extend_length(HCR$FsprLimit)
data_list$Ptarget = extend_length(HCR$Ptarget)
data_list$Plimit = extend_length(HCR$Plimit)
data_list$Alpha = extend_length(HCR$Alpha)
data_list$Pstar = extend_length(HCR$Pstar)
data_list$Sigma = extend_length(HCR$Sigma)
data_list$Fmult = extend_length(HCR$Fmult)
data_list$QnormHCR = qnorm(data_list$Pstar, 0, data_list$Sigma)
if(data_list$HCR == 2 & estimateMode == 2){estimateMode = 4} # If projecting under constant F, run parmeters through obj only
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 2: Load/build parameters ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.character(inits) | is.null(inits)) {
start_par <- suppressWarnings(Rceattle::build_params(data_list = data_list))
} else{
start_par <- inits
}
if(verbose > 0) {message("Step 1: Parameter build complete")}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 3: Load/build map ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.null(map)) {
map <- suppressWarnings(build_map(data_list, start_par, debug = estimateMode > 3, random_rec = random_rec))
} else{
map <- map
}
if(verbose > 0) {message("Step 2: Map build complete")}
map$mapList$ln_Ftarget
start_par$ln_Ftarget
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 4: Get bounds ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.null(bounds)) {
bounds <- Rceattle::build_bounds(param_list = start_par, data_list)
} else {
bounds = bounds
}
if(verbose > 0) {message("Step 3: Param bounds complete")}
bounds$lower$ln_Ftarget
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 5: Setup random effects ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
random_vars <- c()
if (random_rec) {
if(initMode > 0){
random_vars <- c(random_vars , "rec_dev", "init_dev")
} else{
random_vars <- c(random_vars , "rec_dev")
}
}
if(random_q){
random_vars <- c(random_vars , "ln_srv_q_dev")
}
if(random_sel){
random_vars <- c(random_vars , "ln_sel_slp_dev", "sel_inf_dev", "sel_coff_dev")
}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 6: Reorganize data ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
TMBfilename <- "ceattle_v01_10"
Rceattle:::data_check(data_list)
data_list_reorganized <- Rceattle::rearrange_dat(data_list)
data_list_reorganized = c(list(model = TMBfilename), data_list_reorganized)
if(msmMode > 0 & data_list$HCR == 3){
data_list_reorganized$HCR = 0 # Estimate model with F = 0 for the projection if multispecies
}
data_list_reorganized$forecast <- FALSE # Don't include BRPs in likelihood of hindcast
# - Update comp weights, future F (if input) and F_prop from data
if(!is.null(data_list$fleet_control$Comp_weights)){
start_par$comp_weights = data_list$fleet_control$Comp_weights
}
start_par$proj_F_prop = data_list$fleet_control$proj_F_prop
nyrs_proj <- data_list$projyr - data_list$styr + 1
if(!is.null(HCR$FsprTarget) & HCR$HCR == 2){
start_par$ln_Ftarget = matrix(log(HCR$FsprTarget), nrow = data_list$nspp, ncol = nyrs_proj) # Fixed fishing mortality for projections for each species
}
# - Update M1 parameter object from data if initial parameter values input
if(updateM1){
m1 <- array(0, dim = c(data_list$nspp, 2, max(data_list$nages, na.rm = T))) # Set up array
# Initialize from inputs
for (i in 1:nrow(data_list$M1_base)) {
sp <- as.numeric(as.character(data_list$M1_base$Species[i]))
sex <- as.numeric(as.character(data_list$M1_base$Sex[i]))
# Fill in M1 array from fixed values for each sex
if(sex == 0){ sex = c(1, 2)} # If sex = combined/both males and females, fill in both dimensions
for(j in 1:length(sex)){
m1[sp, sex[j], 1:max(data_list$nages, na.rm = T)] <- as.numeric(data_list$M1_base[i,(1:max(data_list$nages, na.rm = T)) + 2])
}
}
start_par$ln_M1 <- log(m1)
}
# - Update alpha for stock-recruit if fixed/prior and initial parameter values input
if(data_list$srr_est_mode %in% c(0,2)){
start_par$rec_pars[,2] <- log(data_list$srr_prior_mean)
}
if(verbose > 0) {message("Step 4: Data rearranged complete")}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 7: Set up parameter bounds ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
L <- c()
U <- c()
for(i in 1:length(map$mapFactor)){
if(names(map$mapFactor)[i] %!in% random_vars){ # Dont have bounds for random effects
L = c(L, unlist(bounds$lower[[i]])[which(!is.na(unlist(map$mapFactor[[i]])) & !duplicated(unlist(map$mapFactor[[i]])))])
U = c(U, unlist(bounds$upper[[i]])[which(!is.na(unlist(map$mapFactor[[i]])) & !duplicated(unlist(map$mapFactor[[i]])))])
}
}
# Dimension check
dim_check <- sapply(start_par, unlist(length)) == sapply(map$mapFactor, unlist(length))
if(sum(dim_check) != length(dim_check)){
stop(print(paste0("Map and parameter objects are not the same size for: ", names(dim_check)[which(dim_check == FALSE)])))
}
dim_check
start_par$ln_Ftarget
HCR$FsprTarget
library(Rceattle)
library(Rceattle)
10000-7264.45
devtools::document()
library(Rceattle)
