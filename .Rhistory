# Single-species GOA pollock, IID recruitment
data("GOApollock") # Single-species data. ?BS2017SS for more information on the data
GOApollock$projyr <- 2020  # Shorten proj year for quicker estimation
model1 <- Rceattle::fit_mod(data_list = GOApollock,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
model1 <- Rceattle::fit_mod(data_list = model1$data_list,
inits = model1$estimated_params, # Initial parameters from PL model
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = TRUE, # Random recruitment
msmMode = 0, # Single species mode
phase = FALSE,
verbose = 1)
inits = model1$estimated_params
TRUE * FALSE
remove.packages("Rceattle")
# Code to run DSEM-linked assessment models
# NOTE: we have to phase the models to get to a better starting point
library(Rceattle)
# Model 1 ----
# Single-species GOA pollock, IID recruitment
data("GOApollock") # Single-species data. ?BS2017SS for more information on the data
GOApollock$projyr <- 2020  # Shorten proj year for quicker estimation
GOApollock$env_data <- GOApollock$env_data %>%
dplyr::mutate(ScaledBT =scale(BTempC))
model1 <- Rceattle::fit_mod(data_list = GOApollock,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
model1 <- Rceattle::fit_mod(data_list = model1$data_list,
inits = model1$estimated_params, # Initial parameters from PL model
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = TRUE, # Random recruitment
msmMode = 0, # Single species mode
phase = FALSE,
verbose = 1)
model1$estimated_params
data_list = BS2017SS;
inits = NULL;
map = NULL;
bounds = NULL;
file = NULL;
estimateMode = 0;
random_rec = FALSE;
random_q = FALSE;
random_sel = FALSE;
HCR = build_hcr();
dsem = build_DSEM()
niter = 3;
msmMode = 0;
avgnMode = 0;
initMode = 2
minNByage = 0;
suitMode = 0;
suit_styr = NULL;
suit_endyr = NULL;
phase = FALSE;
getsd = TRUE;
use_gradient = TRUE;
rel_tol = 1;
control = list(eval.max = 1e+09,
iter.max = 1e+09, trace = 0);
getJointPrecision = TRUE;
loopnum = 5;
verbose = 1;
newtonsteps = 0
recFun = build_srr()
M1Fun = build_M1()
projection_uncertainty = TRUE
bias.correct = FALSE
newtonsteps = 0
getReportCovariance = FALSE
inits = model1$estimated_params
data_list = model1$data_list
random_rec = TRUE
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 0 - Start ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
mod_objects <- list() # Objects for saving
start_time <- Sys.time()
extend_length <- function(x){
if(length(x) == data_list$nspp){ return(x)}
else {return(rep(x, data_list$nspp))}
}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 1 - Load data and switches ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.null(data_list)) {
stop("Missing data_list object")
}
data_list <- Rceattle::clean_data(data_list)
# Add switches from function call
data_list$random_rec <- as.numeric(random_rec)
data_list$estimateMode <- estimateMode
data_list$niter <- niter
data_list$avgnMode <- avgnMode
data_list$initMode <- initMode
data_list$loopnum <- loopnum
data_list$msmMode <- msmMode
data_list$suitMode <- extend_length(suitMode)
# * Suitability switches ----
# -- Start year
if(is.null(suit_styr) & is.null(data_list$suit_styr)){ # If not provided in data or function, use start year
data_list$suit_styr <- data_list$styr
}
if(!is.null(suit_styr)){ # If provided in function, override data
if(!is.null(data_list$suit_styr)){
if(data_list$suit_styr != suit_styr){
warning("'suit_styr' in data is different than in call `fit_mod`, using switch from 'fit_mod'")
}
}
data_list$suit_styr <- suit_styr
}
# -- End year
if(is.null(suit_endyr) & is.null(data_list$suit_endyr)){ # If not provided in data or function, use end year
data_list$suit_endyr <- data_list$endyr
}
if(!is.null(suit_endyr)){ # If provided in function, override data
if(!is.null(data_list$suit_endyr)){
if(data_list$suit_endyr != suit_endyr){
warning("'suit_endyr' in data is different than in call `fit_mod`, using switch from 'fit_mod'")
}
}
data_list$suit_endyr <- suit_endyr
}
# * Recruitment switches ----
data_list$srr_fun <- recFun$srr_fun
data_list$srr_pred_fun <- recFun$srr_pred_fun
data_list$proj_mean_rec <- recFun$proj_mean_rec
if(is.null(recFun$srr_meanyr) & is.null(data_list$srr_meanyr)){ # If no meanyear is provided in data or function, use end year
data_list$srr_meanyr <- data_list$endyr
}
if(!is.null(recFun$srr_meanyr)){ # If mean year is provided in function, override data
if(!is.null(data_list$srr_meanyr)){
if(data_list$srr_meanyr != recFun$srr_meanyr){
warning("'srr_meanyr' in data is different than in call `fit_mod`, using switch from 'fit_mod'")
}
}
data_list$srr_meanyr <- recFun$srr_meanyr
}
# -- Start year
if(is.null(recFun$srr_hat_styr) & is.null(data_list$srr_hat_styr)){ # If not provided in data or function, use start year
data_list$srr_hat_styr <- data_list$styr + 1
}
if(!is.null(recFun$srr_hat_styr)){ # If provided in function, override data
if(!is.null(data_list$srr_hat_styr)){
if(data_list$srr_hat_styr != recFun$srr_hat_styr){
warning("'srr_hat_styr' in data is different than in call `fit_mod`, using switch from 'fit_mod'")
}
}
data_list$srr_hat_styr <- recFun$srr_hat_styr
}
# -- End year
if(is.null(recFun$srr_hat_endyr) & is.null(data_list$srr_hat_endyr)){ # If not provided in data or function, use end year
data_list$srr_hat_endyr <- data_list$endyr
}
if(!is.null(recFun$srr_hat_endyr)){ # If provided in function, override data
if(!is.null(data_list$srr_hat_endyr)){
if(data_list$srr_hat_endyr != recFun$srr_hat_endyr){
warning("'srr_hat_endyr' in data is different than in call `fit_mod`, using switch from 'fit_mod'")
}
}
data_list$srr_hat_endyr <- recFun$srr_hat_endyr
}
data_list$srr_est_mode <- recFun$srr_est_mode
data_list$srr_prior <- extend_length(recFun$srr_prior)
data_list$srr_prior_sd <- extend_length(recFun$srr_prior_sd)
data_list$srr_indices <- recFun$srr_indices
data_list$Bmsy_lim <- extend_length(recFun$Bmsy_lim)
# * M switches ----
if(!is.null(data_list$M1_model)){
if(sum(data_list$M1_model != extend_length(M1Fun$M1_model))){
warning("M1_model in data is different than in call `fit_mod`, using switch from 'fit_mod'")
}
}
# FIXME: may want to pull from data here too??
data_list$M1_model= extend_length(M1Fun$M1_model)
data_list$M1_model = ifelse(data_list$nsex == 1 & data_list$M1_model == 2, 1, data_list$M1_model) # Sex specific to sex-invariant if 1-sex model
data_list$M1_re = extend_length(M1Fun$M1_re)
data_list$M1_use_prior = extend_length(M1Fun$M1_use_prior) * (data_list$M1_model > 0) # Sets to 0 if M1 is fixed
data_list$M2_use_prior = extend_length(M1Fun$M2_use_prior) * (msmMode > 0) # Sets to 0 if single-species
data_list$M_prior = extend_length(M1Fun$M_prior)
data_list$M_prior_sd = extend_length(M1Fun$M_prior_sd)
data_list$M1_indices <- M1Fun$M1_indices
# * HCR Switches ----
# - make length of nspp if not
data_list$HCR = HCR$HCR
data_list$DynamicHCR = HCR$DynamicHCR
if(HCR$HCR != 2){ # Ftarget is also used for fixed F (so may be of length nflts)
data_list$Ftarget = extend_length(HCR$Ftarget)
} else {
data_list$Ftarget = HCR$Ftarget
}
data_list$Flimit = extend_length(HCR$Flimit)
data_list$Ptarget = extend_length(HCR$Ptarget)
data_list$Plimit = extend_length(HCR$Plimit)
data_list$Alpha = extend_length(HCR$Alpha)
data_list$Pstar = extend_length(HCR$Pstar)
data_list$Sigma = extend_length(HCR$Sigma)
data_list$Fmult = extend_length(HCR$Fmult)
data_list$HCRorder = extend_length(HCR$HCRorder)
data_list$QnormHCR = qnorm(data_list$Pstar, 0, data_list$Sigma)
if(data_list$msmMode > 0 & !data_list$HCR %in% c(0, 1, 2, 3, 6)){
warning("WARNING:: Only HCRs 1, 2, 3, and 6 work in multi-species mode currently")
}
# Fill out switches if missing
data_list <- Rceattle::switch_check(data_list)
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 2: DSEM ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# - DSEM check
if(!is.null(data_list$sem) & !is.null(dsem$sem)){
if(data_list$sem != dsem$sem){
warning("'sem' in data is different than in call `fit_mod`, using `sem` from 'fit_mod' if both `map` and `inits` not input")
}
}
# If inits and map are provided, no need to run dsem
if(is.null(inits) | is.null(map)){
dsem_objects <- build_dsem_objects(dsem_settings = dsem,
debug = estimateMode %in% c(2, 4), # Turn off dsem parameters if debugging or projection mode
data_list = data_list)
data_list$sem <- dsem_objects$sem
#FIXME: add dsem_objects to mod_objects?
}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 3: Load/build parameters ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.character(inits) | is.null(inits)) {
start_par <- suppressWarnings(Rceattle::build_params(data_list = data_list))
start_par <- c(start_par, dsem_objects$tmb_inputs$parameters) # Add DSEM parameters
} else{
start_par <- inits
# - Set F for years with 0 catch to very low number
zero_catch <- data_list$catch_data %>%
dplyr::filter(Year <= data_list$endyr &
Catch == 0) %>%
dplyr::mutate(Year = Year - data_list$styr + 1) %>%
dplyr::select(Fleet_code, Year) %>%
as.matrix()
start_par$ln_F[zero_catch] <- -999
rm(zero_catch)
# Update proj F prop
start_par$proj_F_prop <- data_list$fleet_control$proj_F_prop
}
mod_objects$initial_params <- start_par
if(verbose > 0) {message("Step 1: Parameter build complete")}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 4: Load/build map ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.null(map)) {
map <- suppressWarnings(build_map(data_list,
start_par[-which(names(start_par) %in% names(dsem_objects$tmb_inputs$parameters))],
debug = estimateMode %in% c(2, 4), # Turn off hindcast parameters if debugging or projection mode
random_sel = random_sel))
map$mapList <- c(map$mapList, dsem_objects$mapList) # Add DSEM map
map$mapFactor <- c(map$mapFactor, dsem_objects$tmb_inputs$map) # Add DSEM map
} else{
map <- map
}
if(verbose > 0) {message("Step 2: Map build complete")}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 5: Get bounds ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.null(bounds)) {
bounds <- Rceattle::build_bounds(param_list = start_par, data_list)
} else {
bounds = bounds
}
if(verbose > 0) {message("Step 3: Parameter bounds complete")}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 6: Setup random effects ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Turns on laplace approximation
random_vars <- c()
if (random_rec) {
random_vars <- c(dsem_objects$tmb_inputs$random) # x_tj matrix from dsem
if(initMode > 0){
random_vars <- c(random_vars, "init_dev")
}
}
if(random_q){
random_vars <- c(random_vars , "index_q_dev")
}
if(random_sel){
random_vars <- c(random_vars , "ln_sel_slp_dev", "sel_inf_dev", "sel_coff_dev")
}
if(sum(data_list$M1_re) > 0){
random_vars <- c(random_vars, "ln_M1_dev")
}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 7: Reorganize data ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if(!is.null(TMBfilename)){
TMB::compile(paste0(TMBfilename,".cpp"))
dyn.load(dynlib(TMBfilename))
TMBfilename <- basename(TMBfilename)
}
TMBfilename <- "ceattle_v01_12"
# - Check for data errors
Rceattle:::data_check(data_list)
# - Reorganize data for .cpp file
data_list_reorganized <- Rceattle::rearrange_dat(data_list)
data_list_reorganized = c(list(model = TMBfilename), data_list_reorganized)
data_list_reorganized$forecast <- rep(0, data_list_reorganized$nspp)            # Internal hindcast switch
data_list_reorganized <- c(data_list_reorganized, dsem_objects$tmb_inputs$data) # Add dsem data
# - Update comp weights, future F (if input) and F_prop from data
# - Age/length composition
if(!is.null(data_list$fleet_control$Comp_weights)){
start_par$comp_weights = data_list$fleet_control$Comp_weights
}
# - Diet composition
if(!is.null(data_list$Diet_comp_weights)){
start_par$diet_comp_weights = data_list$Diet_comp_weights
}
# - Proportion of projected F to each fleet
start_par$proj_F_prop = data_list$fleet_control$proj_F_prop
# - Fixed fishing mortality for projections for each species
if(!is.null(HCR$Ftarget) & HCR$HCR == 2){
start_par$ln_Ftarget = log(HCR$Ftarget)
}
# - Update M1 parameter object from data if initial parameter values input
if(M1Fun$updateM1){
m1 <- array(0, dim = c(data_list$nspp,
max(data_list$nsex, na.rm = T),
max(data_list$nages, na.rm = T))) # Set up array
# Initialize from inputs
for (i in 1:nrow(data_list$M1_base)) {
sp <- as.numeric(as.character(data_list$M1_base$Species[i]))
sex <- as.numeric(as.character(data_list$M1_base$Sex[i]))
# Handle sex == 0 case for 2-sex species
sex_values <- if (sex == 0) 1:data_list$nsex[sp] else sex
# Fill in M1 array from fixed values for each sex
for(j in 1:length(sex_values)){
m1[sp, sex_values[j], 1:max(data_list$nages, na.rm = T)] <- as.numeric(data_list$M1_base[i,(1:max(data_list$nages, na.rm = T)) + 2])
}
}
start_par$ln_M1 <- log(m1)
}
# - Update alpha for stock-recruit if fixed/prior and initial parameter values input
if(data_list$srr_est_mode %in% c(0,2) & data_list$srr_pred_fun > 3){
start_par$rec_pars[,2] <- log(data_list$srr_prior)
}
if(verbose > 0) {message("Step 4: Data rearrange complete")}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 8: Set up parameter bounds ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
L <- c()
U <- c()
for(i in 1:length(map$mapFactor)){
if(!names(map$mapFactor)[i] %in% random_vars){ # Dont have bounds for random effects
L = c(L, unlist(bounds$lower[[i]])[which(!is.na(unlist(map$mapFactor[[i]])) & !duplicated(unlist(map$mapFactor[[i]])))])
U = c(U, unlist(bounds$upper[[i]])[which(!is.na(unlist(map$mapFactor[[i]])) & !duplicated(unlist(map$mapFactor[[i]])))])
}
}
# Dimension check
start_par <- start_par[names(map$mapFactor), drop = F]
dim_check <- sapply(start_par, function(x) length(unlist(x))) == sapply(map$mapFactor, function(x) length(unlist(x)))
if(sum(dim_check) != length(dim_check)){
stop(paste0("Map and parameter objects are not the same size for: ", names(dim_check)[which(dim_check == FALSE)], collapse = ",  "))
}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 9: Phase hindcast ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Set default phasing
if(is.logical(phase)){
if(phase){
phaseList <- set_phases()
}
}
if(!is.logical(phase)){
warning("Using input phase. Please set phase = TRUE if using defaults.")
phaseList = phase
phase = TRUE
}
step = 5
if(phase & estimateMode %in% c(0,1) ){
if(verbose > 0) {message(paste0("Step ", step,": Phasing begin"))}; step = step + 1
phase_pars <- Rceattle::TMBphase(
data = data_list_reorganized,
parameters = start_par,
map = map$mapFactor,
random = random_vars,
phases = phaseList,
model_name = TMBfilename,
silent = verbose != 2,
use_gradient = use_gradient,
control = control
)
# Save output
mod_objects$phase_params <- phase_pars
start_par <- phase_pars
if(verbose > 0) {message(paste0("Step ", step,": Phasing complete"))}
step = step + 1
}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 10: Fit hindcast ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# * Build ----
if(sum(as.numeric(unlist(map$mapFactor)), na.rm = TRUE) == 0){stop("Map of length 0: all NAs")}
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
random = random_vars,
silent = verbose != 2
)
# -- Save objects
mod_objects <- c(
list(
TMBfilename = TMBfilename,
bounds = bounds,
map = map
),
mod_objects)
if(verbose > 0) {message(paste0("Step ",step, ": Hindcast build complete"))}
step = step + 1
# * Optimize hindcast ----
if(estimateMode %in% c(0,1,2,4)){
opt <- suppressMessages(
TMBhelper::fit_tmb(obj = obj,
fn=obj$fn,
gr=obj$gr,
startpar=obj$par,
lower = L,
upper = U,
loopnum = loopnum,
newtonsteps = newtonsteps,
getsd = getsd,
control = control,
bias.correct = bias.correct,
bias.correct.control=list(sd=getsd),
getJointPrecision = getJointPrecision,
getReportCovariance = getReportCovariance,
quiet = verbose < 2)
)
if(verbose > 0 & estimateMode != 4) {
message("Step ",step, ": Hindcast optimization complete.")
step = step + 1
}
if(verbose > 0 & estimateMode == 4) {
message("Step ",step, ": 'dummy' optimization complete.")
step = step + 1
}
# -- Convergence warnings
if(estimateMode %in% c(0,1)){
if(is.null(opt$SD) & getsd){
message( "#################################################" )
message( "Model did not converge, check 'identified'" )
message( "#################################################" )
# Bad parameter identification
identified <- tryCatch({suppressMessages(TMBhelper::check_estimability(obj))
},
error = function(e){
return("Some gradients are high, please improve optimization and only then use `Check_Identifiable`")
})
# Make into list if gradients were low for diagnostics
if(class(identified) != "character"){
identified_param_list <- obj$env$parList(identified$BadParams$Param_check)
identified_param_list <- rapply(identified_param_list,function(x) ifelse(x==0,"Not estimated",x), how = "replace")
identified_param_list <- rapply(identified_param_list,function(x) ifelse(x==1,"OK",x), how = "replace")
identified_param_list <- rapply(identified_param_list,function(x) ifelse(x==2,"BAD",x), how = "replace")
identified$param_list <- identified_param_list
}
mod_objects$identified <- identified
}
}
}
opt <- suppressMessages(
TMBhelper::fit_tmb(obj = obj,
fn=obj$fn,
gr=obj$gr,
startpar=obj$par,
lower = L,
upper = U,
loopnum = loopnum,
newtonsteps = newtonsteps,
getsd = getsd,
control = control,
bias.correct = bias.correct,
bias.correct.control=list(sd=getsd),
getJointPrecision = getJointPrecision,
getReportCovariance = getReportCovariance,
quiet = verbose < 2)
)
opt <- suppressMessages(
TMBhelper::fit_tmb(obj = obj,
fn=obj$fn,
gr=obj$gr,
startpar=obj$par,
loopnum = loopnum,
newtonsteps = newtonsteps,
getsd = getsd,
control = control,
bias.correct = bias.correct,
bias.correct.control=list(sd=getsd),
getJointPrecision = getJointPrecision,
getReportCovariance = getReportCovariance,
quiet = verbose < 2)
)
remove.packages("Rceattle")
