phase = FALSE,
getsd = FALSE,
verbose = 0)
return(list(kill_sim = FALSE, failure = NA))
},
timeout = 60*timeout)
},
error = function(e){
return(list(kill_sim = TRUE, failure = "OM"))
},
TimeoutException = function(e){
return(list(kill_sim = TRUE, failure = "OM"))
})
if(kill_sim$kill_sim){
break()
}
# -- Set estimate mode back to original
om_use$data_list$estimateMode <- estimate_mode_base
# ------------------------------------------------------------
# 3. GET ACTUAL CATCH FROM OM ----
# - Maybe the OM can't support the TAC
# ------------------------------------------------------------
# - Get realized catch data from OM
new_catch_data <- om_use$data_list$catch_data
dat_fill_ind <- which(new_catch_data$Year %in% new_years)
new_catch_data$Catch[dat_fill_ind] <- om_use$quantities$catch_hat[dat_fill_ind] # Catch from OM
# - Update catch data in OM and EM
om_use$data_list$catch_data <- new_catch_data
em_use$data_list$catch_data <- new_catch_data
# ------------------------------------------------------------
# 4. REFIT ESTIMATION MODEL AND HCR ----
# ------------------------------------------------------------
# - Simulate new survey and comp data
sim_dat <- Rceattle::sim_mod(om_use, simulate = simulate_data)
years_include <- sample_yrs[which(sample_yrs$Year > em_use$data_list$endyr & sample_yrs$Year <= assess_yrs[k]),]
# -- Add newly simulated survey data to EM
new_srv_biom <- sim_dat$index_data[which(abs(sim_dat$index_data$Year) %in% years_include$Year & sim_dat$index_data$Fleet_code %in% years_include$Fleet_code),]
new_srv_biom$Year <- -new_srv_biom$Year
em_use$data_list$index_data <- rbind(em_use$data_list$index_data, new_srv_biom)
em_use$data_list$index_data <- em_use$data_list$index_data[
with(em_use$data_list$index_data, order(Fleet_code, abs(Year))),]
# -- Add newly simulated comp data to EM
new_comp_data <- sim_dat$comp_data[which(abs(sim_dat$comp_data$Year) %in% years_include$Year & sim_dat$comp_data$Fleet_code %in% years_include$Fleet_code),]
new_comp_data$Year <- -new_comp_data$Year
new_comp_data$Sample_size <- new_comp_data$Sample_size * as.numeric(rowSums(new_comp_data[,9:ncol(new_comp_data)]) > 0) # Set sample size to 0 if catch is 0
new_comp_data[,9:ncol(new_comp_data)] <- new_comp_data[,9:ncol(new_comp_data)] + 1 * as.numeric(new_comp_data$Sample_size == 0) # Set all values to 1 if catch is 0
em_use$data_list$comp_data <- rbind(em_use$data_list$comp_data, new_comp_data)
em_use$data_list$comp_data <- em_use$data_list$comp_data[
with(em_use$data_list$comp_data, order(Fleet_code, abs(Year))),]
# Update end year and re-estimate
em_use$data_list$endyr <- assess_yrs[k]
# Update parameters
# -- F_dev
em_use$estimated_params$F_dev <- cbind(em_use$estimated_params$F_dev, matrix(0, nrow= nrow(em_use$estimated_params$F_dev), ncol = length(new_years)))
# -- Time-varying survey catachbilitiy - Assume last year - filled by columns
em_use$estimated_params$index_q_dev <- cbind(em_use$estimated_params$index_q_dev, matrix(em_use$estimated_params$index_q_dev[,ncol(em_use$estimated_params$index_q_dev)], nrow= nrow(em_use$estimated_params$index_q_dev), ncol = length(new_years)))
# -- Time-varing selectivity - Assume last year - filled by columns
ln_sel_slp_dev = array(0, dim = c(2, nflts, 2, nyrs_hind + length(new_years)))  # selectivity deviations paramaters for logistic
sel_inf_dev = array(0, dim = c(2, nflts, 2, nyrs_hind + length(new_years)))  # selectivity deviations paramaters for logistic
sel_coff_dev = array(0, dim = c(nflts, 2, nselages_em, nyrs_hind + length(new_years)))  # selectivity deviations paramaters for non-parameteric
ln_sel_slp_dev[,,,1:nyrs_hind] <- em_use$estimated_params$ln_sel_slp_dev
sel_inf_dev[,,,1:nyrs_hind] <- em_use$estimated_params$sel_inf_dev
sel_coff_dev[,,,1:nyrs_hind] <- em_use$estimated_params$sel_coff_dev
# - Initialize new years with last year
ln_sel_slp_dev[,,,(nyrs_hind + 1):(nyrs_hind + length(new_years))] <- ln_sel_slp_dev[,,,nyrs_hind]
sel_inf_dev[,,,(nyrs_hind + 1):(nyrs_hind + length(new_years))] <- sel_inf_dev[,,,nyrs_hind]
sel_coff_dev[,,,(nyrs_hind + 1):(nyrs_hind + length(new_years))] <- sel_coff_dev[,,,nyrs_hind]
em_use$estimated_params$ln_sel_slp_dev <- ln_sel_slp_dev
em_use$estimated_params$sel_inf_dev <- sel_inf_dev
em_use$estimated_params$sel_coff_dev <- sel_coff_dev
# Restimate
kill_sim <- tryCatch({
R.utils::withTimeout({
em_use <- fit_mod(
data_list = em_use$data_list,
inits = em_use$estimated_params,
map =  NULL,
bounds = NULL,
file = NULL,
estimateMode = ifelse(em_use$data_list$estimateMode < 3, 0, em_use$data_list$estimateMode), # Run hindcast and projection, otherwise debug
HCR = build_hcr(HCR = em_use$data_list$HCR, # Tier3 HCR
DynamicHCR = em_use$data_list$DynamicHCR,
FsprTarget = em_use$data_list$FsprTarget,
FsprLimit = em_use$data_list$FsprLimit,
Ptarget = em_use$data_list$Ptarget,
Plimit = em_use$data_list$Plimit,
Alpha = em_use$data_list$Alpha,
Pstar = em_use$data_list$Pstar,
Sigma = em_use$data_list$Sigma,
Fmult = em_use$data_list$Fmult,
HCRorder = em$data_list$HCRorder
),
recFun = build_srr(srr_fun = em_use$data_list$srr_fun,
srr_pred_fun = em_use$data_list$srr_pred_fun,
proj_mean_rec = em_use$data_list$proj_mean_rec,
srr_meanyr = em_use$data_list$endyr, # Update end year
srr_hat_styr = em_use$data_list$srr_hat_styr,
srr_hat_endyr = em_use$data_list$srr_hat_endyr,
srr_est_mode  = em_use$data_list$srr_est_mode ,
srr_prior = em_use$data_list$srr_prior,
srr_prior_sd = em_use$data_list$srr_prior_sd,
Bmsy_lim = em_use$data_list$Bmsy_lim,
srr_env_indices = em_use$data_list$srr_env_indices),
M1Fun =     build_M1(M1_model= em_use$data_list$M1_model,
updateM1 = FALSE,
M1_use_prior = em_use$data_list$M1_use_prior,
M2_use_prior = em_use$data_list$M2_use_prior,
M_prior = em_use$data_list$M_prior,
M_prior_sd = em_use$data_list$M_prior_sd),
random_rec = em_use$data_list$random_rec,
niter = em_use$data_list$niter,
msmMode = em_use$data_list$msmMode,
avgnMode = em_use$data_list$avgnMode,
suitMode = em_use$data_list$suitMode,
suit_styr = em_use$data_list$suit_styr,
suit_endyr = em_use$data_list$suit_endyr,
initMode = em_use$data_list$initMode,
phase = FALSE,
loopnum = loopnum,
getsd = FALSE,
verbose = 0)
return(list(kill_sim = FALSE, failure = NA))
},
timeout = 60*timeout)
},
error = function(ex) {
return(list(kill_sim = TRUE, failure = "EM"))
},
TimeoutException = function(ex) {
return(list(kill_sim = TRUE, failure = "EM"))
})
if(is.null(em_use)){
return(list(kill_sim = TRUE, failure = "EM"))
break()
}
# plot_biomass(list(em_use, om_use), model_names = c("EM", "OM"))
# End year of assessment
# - Remove unneeded bits for memory reasons
em_use$initial_params <- NULL
em_use$bounds <- NULL
em_use$map <- NULL
em_use$obj <- NULL
em_use$opt <- NULL
em_use$sdrep <- NULL
em_use$quantities[names(em_use$quantities) %!in% c("catch_hat",
"ln_catch_sd",
"index_hat",
"ln_index_sd",
"ssb_depletion",
"biomass_depletion",
"biomass",
"ssb",
"BO",
"SB0",
"SBF",
"F_spp",
"R",
"M1_at_age",
"M_at_age",
"avg_rec",
"DynamicB0",
"DynamicSB0",
"DynamicSBF",
"SPR0",
"SPRlimit",
"SPRtarget",
"Ftarget",
"Flimit")] <- NULL
sim_list$EM[[k+1]] <- em_use
#sim_list$OM[[k+1]] <- om_use
message(paste0("Sim ",sim, " - EM Year ", assess_yrs[k], " COMPLETE"))
}
# - Rename models
sim_list$use_sim <- !kill_sim$kill_sim
sim_list$failure = kill_sim$failure
sim_list$OM <- om_use # OM
sim_list$OM_no_F <- Rceattle::remove_F(om_use) # OM with no Fishing
if(!kill_sim$kill_sim){
names(sim_list$EM) <- c("EM", paste0("OM_Sim_",sim,". EM_yr_", assess_yrs))
}
#' Function to update hindcast and set F to 0. Useful for determining dynamic reference points for multi-species models under climate-change
#'
#' @param Rceattle
#'
#' @return
#' @export
#'
#' @examples
remove_F <- function(Rceattle){
# * Years for F = 0 ----
# - don't want hindcast or it will bias suitability in Multi-species models
proj_years <- (Rceattle$data_list$suit_endyr+1):Rceattle$data_list$projyr - Rceattle$data_list$styr + 1
fdevs_cols <- 1:ncol(Rceattle$estimated_params$F_dev)
fdevs_change <- which(fdevs_cols %in% proj_years)
# * Set F to 0 ----
Rceattle$estimated_params$F_dev[,fdevs_change] <- replace(Rceattle$estimated_params$F_dev[,fdevs_change], values = -999)
# * Update fit ----
estMode <- Rceattle$data_list$estimateMode
Rceattle <- fit_mod(
data_list = Rceattle$data_list,
inits = Rceattle$estimated_params,
map =  NULL,
bounds = NULL,
file = NULL,
estimateMode = 3,
HCR = build_hcr(HCR = Rceattle$data_list$HCR, # Tier3 HCR
DynamicHCR = Rceattle$data_list$DynamicHCR,
FsprTarget = Rceattle$data_list$FsprTarget,
FsprLimit = Rceattle$data_list$FsprLimit,
Ptarget = Rceattle$data_list$Ptarget,
Plimit = Rceattle$data_list$Plimit,
Alpha = Rceattle$data_list$Alpha,
Pstar = Rceattle$data_list$Pstar,
Sigma = Rceattle$data_list$Sigma,
Fmult = Rceattle$data_list$Fmult,
HCRorder = Rceattle$data_list$HCRorder
),
recFun = build_srr(srr_fun = Rceattle$data_list$srr_fun,
srr_pred_fun  = Rceattle$data_list$srr_pred_fun ,
proj_mean_rec  = Rceattle$data_list$proj_mean_rec ,
srr_meanyr = min(Rceattle$data_list$srr_meanyr, Rceattle$data_list$endyr), # Update end year if less than srr_meanyr
srr_hat_styr = Rceattle$data_list$srr_hat_styr,
srr_hat_endyr = Rceattle$data_list$srr_hat_endyr,
srr_est_mode  = Rceattle$data_list$srr_est_mode ,
srr_prior  = Rceattle$data_list$srr_prior,
srr_prior_sd   = Rceattle$data_list$srr_prior_sd,
Bmsy_lim = Rceattle$data_list$Bmsy_lim,
srr_env_indices = Rceattle$data_list$srr_env_indices),
M1Fun =     build_M1(M1_model= Rceattle$data_list$M1_model,
updateM1 = FALSE,
M1_use_prior = Rceattle$data_list$M1_use_prior,
M2_use_prior = Rceattle$data_list$M2_use_prior,
M_prior = Rceattle$data_list$M_prior,
M_prior_sd = Rceattle$data_list$M_prior_sd),
random_rec = Rceattle$data_list$random_rec,
niter = Rceattle$data_list$niter,
msmMode = Rceattle$data_list$msmMode,
avgnMode = Rceattle$data_list$avgnMode,
suitMode = Rceattle$data_list$suitMode,
suit_styr = Rceattle$data_list$suit_styr,
suit_endyr = min(Rceattle$data_list$suit_endyr, Rceattle$data_list$endyr),   # Update to end year if less than suit_endyr
initMode = Rceattle$data_list$initMode,
phase = NULL,
loopnum = Rceattle$data_list$loopnum,
getsd = TRUE,
verbose = 0)
Rceattle$data_list$estimateMode <- estMode
return(Rceattle)
}
sim_list$OM_no_F <- remove_F(om_use) # OM with no Fishing
#' Function to update hindcast and set F to 0. Useful for determining dynamic reference points for multi-species models under climate-change
#'
#' @param Rceattle
#'
#' @return
#' @export
#'
#' @examples
remove_F <- function(Rceattle){
# * Years for F = 0 ----
# - don't want hindcast or it will bias suitability in Multi-species models
proj_years <- (Rceattle$data_list$suit_endyr+1):Rceattle$data_list$projyr - Rceattle$data_list$styr + 1
fdevs_cols <- 1:ncol(Rceattle$estimated_params$F_dev)
fdevs_change <- which(fdevs_cols %in% proj_years)
# * Set F to 0 ----
Rceattle$estimated_params$F_dev[,fdevs_change] <- replace(Rceattle$estimated_params$F_dev[,fdevs_change], values = -999)
# * Update fit ----
estMode <- Rceattle$data_list$estimateMode
Rceattle <- fit_mod(
data_list = Rceattle$data_list,
inits = Rceattle$estimated_params,
map =  NULL,
bounds = NULL,
file = NULL,
estimateMode = 3,
HCR = build_hcr(HCR = Rceattle$data_list$HCR, # Tier3 HCR
DynamicHCR = Rceattle$data_list$DynamicHCR,
FsprTarget = Rceattle$data_list$FsprTarget,
FsprLimit = Rceattle$data_list$FsprLimit,
Ptarget = Rceattle$data_list$Ptarget,
Plimit = Rceattle$data_list$Plimit,
Alpha = Rceattle$data_list$Alpha,
Pstar = Rceattle$data_list$Pstar,
Sigma = Rceattle$data_list$Sigma,
Fmult = Rceattle$data_list$Fmult,
HCRorder = Rceattle$data_list$HCRorder
),
recFun = build_srr(srr_fun = Rceattle$data_list$srr_fun,
srr_pred_fun  = Rceattle$data_list$srr_pred_fun ,
proj_mean_rec  = Rceattle$data_list$proj_mean_rec ,
srr_meanyr = min(Rceattle$data_list$srr_meanyr, Rceattle$data_list$endyr), # Update end year if less than srr_meanyr
srr_hat_styr = Rceattle$data_list$srr_hat_styr,
srr_hat_endyr = Rceattle$data_list$srr_hat_endyr,
srr_est_mode  = Rceattle$data_list$srr_est_mode ,
srr_prior  = Rceattle$data_list$srr_prior,
srr_prior_sd   = Rceattle$data_list$srr_prior_sd,
Bmsy_lim = Rceattle$data_list$Bmsy_lim,
srr_env_indices = Rceattle$data_list$srr_env_indices),
M1Fun =     build_M1(M1_model= Rceattle$data_list$M1_model,
updateM1 = FALSE,
M1_use_prior = Rceattle$data_list$M1_use_prior,
M2_use_prior = Rceattle$data_list$M2_use_prior,
M_prior = Rceattle$data_list$M_prior,
M_prior_sd = Rceattle$data_list$M_prior_sd),
random_rec = Rceattle$data_list$random_rec,
niter = Rceattle$data_list$niter,
msmMode = Rceattle$data_list$msmMode,
avgnMode = Rceattle$data_list$avgnMode,
suitMode = Rceattle$data_list$suitMode,
suit_styr = Rceattle$data_list$suit_styr,
suit_endyr = min(Rceattle$data_list$suit_endyr, Rceattle$data_list$endyr),   # Update to end year if less than suit_endyr
initMode = Rceattle$data_list$initMode,
phase = FALSE,
loopnum = Rceattle$data_list$loopnum,
getsd = TRUE,
verbose = 0)
Rceattle$data_list$estimateMode <- estMode
return(Rceattle)
}
sim_list$OM_no_F <- remove_F(om_use) # OM with no Fishing
if(!kill_sim$kill_sim){
names(sim_list$EM) <- c("EM", paste0("OM_Sim_",sim,". EM_yr_", assess_yrs))
}
# - Save
if(!is.null(dir)){
dir.create(file.path(getwd(), dir), showWarnings = FALSE, recursive = TRUE)
saveRDS(sim_list, file = paste0(dir, "/", file, "EMs_from_OM_Sim_",sim, ".rds"))
sim_list <- NULL
} else{
sim_list # Return simlist
}
# Load libraries ----
library(Rceattle)
library(readxl)
library(dplyr)
# Read in data ----
# - The data can be modified in excel or R
mydata_pollock <- Rceattle::read_data( file = "GOA_24_pollock_single_species_1970-2024.xlsx")
# FIT HINDCASTS ----
# 1) Fit base single-species model ----
# - fixed M, multinomial, no stock-recruit curve
pollock_base <- fit_mod(data_list = mydata_pollock,
inits = NULL,       # Initial parameters = 0
file = NULL,        # Don't save
estimateMode = 0,   # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0,        # Single species mode
verbose = 1,        # Minimal messages
initMode = 1,       # Unfished equilibrium with init_dev's turned off
phase = TRUE)       # Phase
# 2) Estimate age-invariant M ----
pollock_estM <- fit_mod(data_list = mydata_pollock,
inits = NULL,       # Initial parameters = 0
file = NULL,        # Don't save
estimateMode = 0,   # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0,        # Single species mode
verbose = 1,        # Minimal messages
M1Fun = build_M1(M1_model = 1), # Estimate age and time invariant M: see ?build_M1 for more details
initMode = 1,       # Unfished equilibrium with init_dev's turned off
phase = TRUE)       # Phase
# 3) Estimate age-invariant M and Ricker SRR ----
pollock_estM_ricker <- fit_mod(data_list = mydata_pollock,
inits = NULL,       # Initial parameters = 0
file = NULL,        # Don't save
estimateMode = 0,   # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0,        # Single species mode
verbose = 1,        # Minimal messages
M1Fun = build_M1(M1_model = 1), # Estimate age and time invariant M: see ?build_M1 for more details
recFun = build_srr(srr_fun = 0, # Default no-stock recruit curve
srr_pred_fun = 4, # Ricker curve as additional penalty sensu Ianelli (if srr_fun and srr_pred_fun are the same, no penalty is used)
srr_est_mode = 1, # Freely estimate alpha
srr_hat_styr = 1977, # Estimate starting 7 years after styr = 1970
srr_hat_endyr = 2020
),
initMode = 1,       # Unfished equilibrium with init_dev's turned off
phase = TRUE)       # Phase
# PROJECTIONS ----
# - Can also be done above
pollock_base_tier3 <- fit_mod(data_list = pollock_base$data_list,
inits = pollock_base$estimated_params,       # Initial parameters = 0
file = NULL,             # Don't save
estimateMode = 2,        # Estimate projection only
random_rec = FALSE,      # No random recruitment
msmMode = 0,             # Single species mode
verbose = 1,             # Minimal messages
initMode = 1,            # Unfished equilibrium with init_dev's turned off
phase = FALSE,           # Don't Phase
HCR = build_hcr(HCR = 5, # Tier3 HCR
FsprTarget = 0.4, # F40% - SPR
FsprLimit = 0.35, # F35% - SPR
Plimit = c(0.2),  # No fishing when SB<SB20
Alpha = 0.05))
# PLOTS ----
mod_list <- list(pollock_base, pollock_estM, pollock_estM_ricker, pollock_base_tier3)
model_names <- c("Base", "est M", "M & Ricker", "Base Tier 3")
# * Time-series ----
plot_biomass(mod_list, model_names = model_names)
plot_recruitment(mod_list, model_names = model_names)
plot_ssb(mod_list, model_names = model_names, add_ci = TRUE, incl_proj = TRUE)
plot_stock_recruit(pollock_estM_ricker)
plot_selectivity(pollock_estM_ricker)
# * Diagnostics ----
plot_index(mod_list, model_names = model_names)
plot_catch(mod_list, model_names = model_names)
plot_comp(pollock_estM_ricker)
# RETROSPECTIVES ----
pollock_base_retro <- retrospective(pollock_base, peels = 5)
plot_biomass(pollock_base_retro$Rceattle_list,
model_names = paste("Mohn's rho =", round(pollock_base_retro$mohns[1,2], 3)))
# MSE ----
mse <- mse_run_parallel(om = pollock_estM_ricker, # Ricker OM
em = pollock_base_tier3,  # Fixed M EM w/ Tier 3 HCR
nsim = 1,
assessment_period = 1, sampling_period = 1, # Can be a vector
simulate_data = TRUE, sample_rec = TRUE,
dir = NULL, file = NULL)
#
plot_biomass(mse[[1]]$EM)
plot_biomass(mse[[1]]$EM, reference = mse[[1]]$OM)
plot_biomass(mse[[1]]$EM, reference = mse[[1]]$OM, mod_avg = FALSE)
plot_biomass(mse[[1]]$EM, reference = mse[[1]]$OM)
plot_biomass(mse[[1]]$EM, reference = mse[[1]]$OM)
source("~/Documents/GitHub/Rceattle/R/7a-plot_ceattle.R", echo=TRUE)
plot_biomass(mse[[1]]$EM, reference = mse[[1]]$OM)
plot_depletionSSB(mse[[1]]$EM, reference = mse[[1]]$OM)
plot_depletionSSB(mse[[1]]$EM)
plot_depletionSSB(mse[[1]]$EM, reference = mse[[1]]$OM)
source("~/Documents/GitHub/Rceattle/R/7a-plot_ceattle.R", echo=TRUE)
plot_biomass(mse[[1]]$EM, reference = mse[[1]]$OM)
plot_depletionSSB(mse[[1]]$EM, reference = mse[[1]]$OM)
# Load libraries ----
library(Rceattle)
library(readxl)
library(dplyr)
# Read in data ----
# - The data can be modified in excel or R
mydata_pollock <- Rceattle::read_data( file = "GOA_24_pollock_single_species_1970-2024.xlsx")
# FIT HINDCASTS ----
# 1) Fit base single-species model ----
# - fixed M, multinomial, no stock-recruit curve
pollock_base <- fit_mod(data_list = mydata_pollock,
inits = NULL,       # Initial parameters = 0
file = NULL,        # Don't save
estimateMode = 0,   # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0,        # Single species mode
verbose = 1,        # Minimal messages
initMode = 1,       # Unfished equilibrium with init_dev's turned off
phase = TRUE)       # Phase
# 2) Estimate age-invariant M ----
pollock_estM <- fit_mod(data_list = mydata_pollock,
inits = NULL,       # Initial parameters = 0
file = NULL,        # Don't save
estimateMode = 0,   # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0,        # Single species mode
verbose = 1,        # Minimal messages
M1Fun = build_M1(M1_model = 1), # Estimate age and time invariant M: see ?build_M1 for more details
initMode = 1,       # Unfished equilibrium with init_dev's turned off
phase = TRUE)       # Phase
# 3) Estimate age-invariant M and Ricker SRR ----
pollock_estM_ricker <- fit_mod(data_list = mydata_pollock,
inits = NULL,       # Initial parameters = 0
file = NULL,        # Don't save
estimateMode = 0,   # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0,        # Single species mode
verbose = 1,        # Minimal messages
M1Fun = build_M1(M1_model = 1), # Estimate age and time invariant M: see ?build_M1 for more details
recFun = build_srr(srr_fun = 0, # Default no-stock recruit curve
srr_pred_fun = 4, # Ricker curve as additional penalty sensu Ianelli (if srr_fun and srr_pred_fun are the same, no penalty is used)
srr_est_mode = 1, # Freely estimate alpha
srr_hat_styr = 1977, # Estimate starting 7 years after styr = 1970
srr_hat_endyr = 2020
),
initMode = 1,       # Unfished equilibrium with init_dev's turned off
phase = TRUE)       # Phase
# PROJECTIONS ----
# - Can also be done above
pollock_base_tier3 <- fit_mod(data_list = pollock_base$data_list,
inits = pollock_base$estimated_params,       # Initial parameters = 0
file = NULL,             # Don't save
estimateMode = 2,        # Estimate projection only
random_rec = FALSE,      # No random recruitment
msmMode = 0,             # Single species mode
verbose = 1,             # Minimal messages
initMode = 1,            # Unfished equilibrium with init_dev's turned off
phase = FALSE,           # Don't Phase
HCR = build_hcr(HCR = 5, # Tier3 HCR
FsprTarget = 0.4, # F40% - SPR
FsprLimit = 0.35, # F35% - SPR
Plimit = c(0.2),  # No fishing when SB<SB20
Alpha = 0.05))
# PLOTS ----
mod_list <- list(pollock_base, pollock_estM, pollock_estM_ricker, pollock_base_tier3)
model_names <- c("Base", "est M", "M & Ricker", "Base Tier 3")
# * Time-series ----
plot_biomass(mod_list, model_names = model_names)
plot_recruitment(mod_list, model_names = model_names)
plot_ssb(mod_list, model_names = model_names, add_ci = TRUE, incl_proj = TRUE)
plot_recruitment(mod_list, model_names = model_names, add_ci = TRUE)
# * Time-series ----
plot_biomass(mod_list, model_names = model_names, add_ci = TRUE)
library(Rceattle)
library(dplyr)
library(readxl)
################################################
# Data
################################################
hakedata <- Rceattle::read_data(file = "Data/NEW_ATF_hake_intrasp_250207.xlsx")
