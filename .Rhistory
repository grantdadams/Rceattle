Pstar = data_list$Pstar,
Sigma = data_list$Sigma,
Fmult = data_list$Fmult,
HCRorder = data_list$HCRorder
),
recFun = build_srr(srr_fun = data_list$srr_fun,
srr_pred_fun  = data_list$srr_pred_fun ,
proj_mean_rec  = data_list$proj_mean_rec ,
srr_meanyr = min(data_list$srr_meanyr, data_list$endyr), # Update end year if less than srr_meanyr
srr_hat_styr = data_list$srr_hat_styr,
srr_hat_endyr = data_list$srr_hat_endyr,
srr_est_mode  = data_list$srr_est_mode ,
srr_prior  = data_list$srr_prior,
srr_prior_sd   = data_list$srr_prior_sd,
Bmsy_lim = data_list$Bmsy_lim,
srr_indices = data_list$srr_indices),
M1Fun =     build_M1(M1_model = data_list$M1_model,
M1_re = data_list$M1_re,
updateM1 = FALSE,  # Dont update M1 from data, start at previous parameters
M1_use_prior = data_list$M1_use_prior,
M2_use_prior = data_list$M2_use_prior,
M_prior = data_list$M_prior,
M_prior_sd = data_list$M_prior_sd,
M1_indices = data_list$M1_indices),
random_rec = data_list$random_rec,
niter = data_list$niter, # Grant: you don't want this to be different than the original model or else youll get a different MLE
msmMode = data_list$msmMode,
avgnMode = data_list$avgnMode,
suitMode = data_list$suitMode,
suit_styr = data_list$suit_styr,
suit_endyr = min(data_list$suit_endyr, data_list$endyr),   # Update to end year if less than suit_endyr
initMode = data_list$initMode,
phase = FALSE,
loopnum = 1, # Grant: lowering the number of "nlminb" calls to 1
getsd = FALSE, # No sd for speed
verbose = 0
)
# Add profiling information
mod_prof$vulnerability_value <- vulnerability_vec[i]
mod_prof$log_phi_value <- new_log_phi[prey_species]
mod_prof$vulnerability_other <- 1 - sum(target_vuln)
mod_prof$pred_species <- pred_species
mod_prof$prey_species <- prey_species
mod_prof$profile_success <- TRUE
# Grant: changing to "mod_prof$opt$objective"
if(!is.finite(mod_prof$opt$objective)) {
mod_prof$profile_success <- FALSE
mod_prof$error_message <- "Non-finite objective value"
}
return(mod_prof)
}, error = function(e) {
return(list(
vulnerability_value = vulnerability_vec[i],
log_phi_value = NA,
vulnerability_other = NA,
pred_species = pred_species,
prey_species = prey_species,
profile_success = FALSE,
error_message = as.character(e),
opt = list(opt = list(objective = NA, Convergence_check = "Failed"))
))
})
}
stopImplicitCluster()
closeAllConnections()
gc()
return(profile_list)
}
# MULTI-PREY PROFILING: Profile all prey of a predator simultaneously
profile_multi_prey_vulnerability <- function(model, pred_species, n_points_per_prey = 5,
verbose = TRUE, min_other = 0.01) {
# Get current vulnerabilities
current_vuln <- get_vulnerabilities_from_model(model)
n_prey <- ncol(current_vuln$vulnerability)
# Create vulnerability ranges for each prey using log scale for better coverage
max_individual_vuln <- 1-min_other # (1 - min_other) / n_prey  # Conservative upper bound
# Grant: this upper bound may be lower than the estimated vulnerability for a prey
# It may make sense to do it from vuln +- 0.2 or something
vulnerability_ranges <- lapply(1:n_prey, function(i) {seq(
from = max(c(0, current_vuln$vulnerability[pred_species,i] - 0.2)),
to = min(c(1, current_vuln$vulnerability[pred_species,i] + 0.2)),
length.out = n_points_per_prey
)
})
# Create all combinations
vulnerability_grid <- expand.grid(vulnerability_ranges)
names(vulnerability_grid) <- paste0("prey_", 1:n_prey)
# Filter combinations that are feasible
feasible_rows <- apply(vulnerability_grid, 1, function(row) {
check_vulnerability_feasible(as.numeric(row), min_other)
})
valid_combinations <- vulnerability_grid[feasible_rows, ]
if(nrow(valid_combinations) == 0) {
stop("No valid vulnerability combinations found")
}
if(verbose) {
cat("Profiling predator", pred_species, "with", n_prey, "prey\n")
cat("Valid combinations:", nrow(valid_combinations), "out of", nrow(vulnerability_grid), "\n")
row_sums <- rowSums(valid_combinations)
cat("Vulnerability sum range:", round(min(row_sums), 6), "to", round(max(row_sums), 3), "\n")
cat("Minimum vulnerability to other food:", round(min_other, 3), "\n")
}
# Set up parallel processing
library(foreach)
library(doParallel)
cores <- min(detectCores() - 1, nrow(valid_combinations), 4)
registerDoParallel(cores)
profile_list <- foreach(i = 1:nrow(valid_combinations), .packages = c("Rceattle", "dplyr")) %dopar% {
tryCatch({
# Start with original estimated parameters
inits <- model$estimated_params
# Get target vulnerabilities for this combination
target_vulnerabilities <- as.numeric(valid_combinations[i, ])
# Convert to log_phi (this correctly calculates vulnerability_other for this combination)
new_log_phi <- inverse_multinomial_logit_multi(target_vulnerabilities, model, pred_species)
inits$log_phi[pred_species, ] <- new_log_phi
# Build map - fix all log_phi for this predator
data_list <- model$data_list
map <- model$map
# Fix the log_phi parameters we're profiling
map$mapList$log_phi[pred_species, ] <- NA
map$mapFactor$log_phi <- factor(map$mapList$log_phi)
# Fit the model
# Grant: added all the other model bits in case you switch things up
mod_prof <- Rceattle::fit_mod(
data_list = data_list,
inits = inits,
map = map,
bounds = NULL,
file = NULL,
estimateMode = 0,
HCR = build_hcr(HCR = data_list$HCR,
DynamicHCR = data_list$DynamicHCR,
Ftarget = data_list$Ftarget,
Flimit = data_list$Flimit,
Ptarget = data_list$Ptarget,
Plimit = data_list$Plimit,
Alpha = data_list$Alpha,
Pstar = data_list$Pstar,
Sigma = data_list$Sigma,
Fmult = data_list$Fmult,
HCRorder = data_list$HCRorder
),
recFun = build_srr(srr_fun = data_list$srr_fun,
srr_pred_fun  = data_list$srr_pred_fun ,
proj_mean_rec  = data_list$proj_mean_rec ,
srr_meanyr = data_list$srr_meanyr,
srr_hat_styr = data_list$srr_hat_styr,
srr_hat_endyr = data_list$srr_hat_endyr,
srr_est_mode  = data_list$srr_est_mode ,
srr_prior  = data_list$srr_prior,
srr_prior_sd   = data_list$srr_prior_sd,
Bmsy_lim = data_list$Bmsy_lim,
srr_indices = data_list$srr_indices),
M1Fun =     build_M1(M1_model = data_list$M1_model,
M1_re = data_list$M1_re,
updateM1 = FALSE,  # Dont update M1 from data, start at previous parameters
M1_use_prior = data_list$M1_use_prior,
M2_use_prior = data_list$M2_use_prior,
M_prior = data_list$M_prior,
M_prior_sd = data_list$M_prior_sd,
M1_indices = data_list$M1_indices),
random_rec = data_list$random_rec,
niter = data_list$niter, # Grant: you don't want this to be different than the original model or else youll get a different MLE
msmMode = data_list$msmMode,
avgnMode = data_list$avgnMode,
suitMode = data_list$suitMode,
suit_styr = data_list$suit_styr,
suit_endyr = data_list$suit_endyr,
initMode = data_list$initMode,
phase = FALSE,
loopnum = 1, # Grant: lowering the number of "nlminb" calls to 1
getsd = FALSE, # No sd for speed
verbose = 0
)
# Add profiling information
mod_prof$vulnerability_values <- target_vulnerabilities
mod_prof$log_phi_values <- new_log_phi
mod_prof$vulnerability_other <- 1 - sum(target_vulnerabilities)
mod_prof$pred_species <- pred_species
mod_prof$profile_success <- TRUE
# Grant: changing to "mod_prof$opt$objective"
if(!is.finite(mod_prof$opt$objective)) {
mod_prof$profile_success <- FALSE
mod_prof$error_message <- "Non-finite objective value"
}
return(mod_prof)
}, error = function(e) {
return(list(
vulnerability_values = as.numeric(valid_combinations[i, ]),
log_phi_values = rep(NA, n_prey),
vulnerability_other = NA,
pred_species = pred_species,
profile_success = FALSE,
error_message = as.character(e),
opt = list(opt = list(objective = NA, Convergence_check = "Failed"))
))
})
}
stopImplicitCluster()
closeAllConnections()
gc()
return(profile_list)
}
# EXTRACT RESULTS FOR SINGLE PREY PROFILING
# Grant: Guessing this function could be used for both profile types
extract_single_prey_profile <- function(profile_list) {
results <- data.frame(
vulnerability_value = sapply(profile_list, function(x) {
if(is.null(x$vulnerability_value)) return(NA) else return(x$vulnerability_value)
}),
log_phi_value = sapply(profile_list, function(x) {
if(is.null(x$log_phi_value)) return(NA) else return(x$log_phi_value)
}),
vulnerability_other = sapply(profile_list, function(x) {
if(is.null(x$vulnerability_other)) return(NA) else return(x$vulnerability_other)
}),
objective = sapply(profile_list, function(x) {
if(is.null(x$opt$objective)) return(NA) else return(x$opt$objective)
}),
convergence_check = sapply(profile_list, function(x) {
if(is.null(x$opt$Convergence_check)) return("Unknown") else return(x$opt$Convergence_check)
}),
converged = sapply(profile_list, function(x) {
if(is.null(x$opt$Convergence_check)) return(FALSE)
else return(x$opt$Convergence_check == "relative convergence (4)")
}),
profile_success = sapply(profile_list, function(x) {
if(is.null(x$profile_success)) return(FALSE) else return(x$profile_success)
}),
pred_species = sapply(profile_list, function(x) {
if(is.null(x$pred_species)) return(NA) else return(x$pred_species)
}),
prey_species = sapply(profile_list, function(x) {
if(is.null(x$prey_species)) return(NA) else return(x$prey_species)
})
)
# Calculate delta log-likelihood (profile likelihood)
if(any(!is.na(results$objective))) {
min_nll <- min(results$objective[results$profile_success], na.rm = TRUE)
results$delta_nll <- results$objective - min_nll
results$profile_likelihood <- exp(-results$delta_nll)
}
return(results)
}
# EXTRACT RESULTS FOR MULTI-PREY PROFILING
extract_multi_prey_profile <- function(profile_list) {
n_prey <- length(profile_list[[1]]$vulnerability_values)
# Create base results
results <- data.frame(
objective = sapply(profile_list, function(x) {
if(is.null(x$opt$objective)) return(NA) else return(x$opt$objective)
}),
vulnerability_other = sapply(profile_list, function(x) {
if(is.null(x$vulnerability_other)) return(NA) else return(x$vulnerability_other)
}),
convergence_check = sapply(profile_list, function(x) {
if(is.null(x$opt$Convergence_check)) return("Unknown") else return(x$opt$Convergence_check)
}),
converged = sapply(profile_list, function(x) {
if(is.null(x$opt$Convergence_check)) return(FALSE)
else return(x$opt$Convergence_check == "relative convergence (4)")
}),
profile_success = sapply(profile_list, function(x) {
if(is.null(x$profile_success)) return(FALSE) else return(x$profile_success)
}),
pred_species = sapply(profile_list, function(x) {
if(is.null(x$pred_species)) return(NA) else return(x$pred_species)
})
)
# Add vulnerability and log_phi columns
for(i in 1:n_prey) {
results[[paste0("vulnerability_prey_", i)]] <- sapply(profile_list, function(x) {
if(is.null(x$vulnerability_values)) return(NA) else return(x$vulnerability_values[i])
})
results[[paste0("log_phi_prey_", i)]] <- sapply(profile_list, function(x) {
if(is.null(x$log_phi_values)) return(NA) else return(x$log_phi_values[i])
})
}
# Add total vulnerability
vuln_cols <- grep("vulnerability_prey_", names(results), value = TRUE)
results$total_vulnerability <- rowSums(results[vuln_cols], na.rm = TRUE)
# Calculate delta log-likelihood (profile likelihood)
if(any(!is.na(results$objective))) {
min_nll <- min(results$objective[results$profile_success], na.rm = TRUE)
results$delta_nll <- results$objective - min_nll
results$profile_likelihood <- exp(-results$delta_nll)
}
return(results)
}
# SIMPLIFIED PLOTTING FUNCTION (without confidence intervals)
plot_single_prey_profile <- function(profile_results, pred_species = NULL, prey_species = NULL) {
valid_results <- profile_results[profile_results$profile_success & !is.na(profile_results$objective), ]
if(nrow(valid_results) == 0) {
stop("No valid profile results to plot")
}
title_text <- paste("Vulnerability Profile: Predator", pred_species, "-> Prey", prey_species)
plot(valid_results$vulnerability_value, valid_results$objective,
type = "l", xlab = "Vulnerability", ylab = "Negative Log-Likelihood",
main = title_text, lwd = 2)
points(valid_results$vulnerability_value, valid_results$objective, pch = 16, cex = 0.8)
# Add minimum point
min_idx <- which.min(valid_results$objective)
points(valid_results$vulnerability_value[min_idx], valid_results$objective[min_idx],
pch = 16, cex = 1.2, col = "red")
# Add grid for better readability
grid()
}
# IMPLEMENTATION EXAMPLES ----
# Example 1: Profile single prey vulnerability
single_prey_profile <- profile_single_prey_vulnerability(
model = run_ms_LN,
pred_species = 3,
prey_species = 1
)
run_ms_LN$quantities$vulnerability
run_ms_LN$quantities$jnll
single_results <- extract_single_prey_profile(single_prey_profile)
plot_single_prey_profile(single_results, pred_species = 3, prey_species = 1)
# Example 2: Profile all prey for a predator
multi_prey_profile <- profile_multi_prey_vulnerability(
model = run_ms_LN,
pred_species = 3,
n_points_per_prey = 10
)
multi_results <- extract_multi_prey_profile(multi_prey_profile)
# Find best combination
best_idx <- which.min(multi_results$objective[multi_results$profile_success])
best_combination <- multi_results[best_idx, ]
print(best_combination)
library(Rceattle)
################################################
# Data
################################################
# Example
# To run the 2017 single species assessment for the Bering Sea, a data file must first be loaded:
data("BS2017SS") # Single-species data. ?BS2017SS for more information on the data
data("BS2017MS") # Multi-species data. Note: the only difference is the residual mortality (M1_base) is lower
# Write data to excel
Rceattle::write_data(data_list = BS2017SS, file = "BS2017SS.xlsx")
# Change the data how you want in excel
# Read the data back in
mydata <- Rceattle::read_data( file = "BS2017SS.xlsx")
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
# Single-species, but estimate M
ss_run_M <- Rceattle::fit_mod(data_list = mydata,
inits = ss_run$estimated_params, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
M1Fun = build_M1(M1_model = 1,
M1_use_prior = FALSE,
M2_use_prior = FALSE),
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = TRUE,
verbose = 1)
plot_biomass(ss_run_M, add_ci = TRUE)
# - Multi-species
# For the a multispecies model we from the single species parameters.
ms_run <- Rceattle::fit_mod(data_list = BS2017MS,
inits = ss_run$estimated_params, # Initial parameters from single species ests
M1Fun = build_M1(M1_model = 1,
updateM1 = TRUE,
M1_use_prior = FALSE,
M2_use_prior = FALSE),
file = NULL, # Don't save
estimateMode = 0, # Estimate
niter = 3, # 3 iterations around population and predation dynamics
random_rec = FALSE, # No random recruitment
msmMode = 1, # MSVPA based
suitMode = 0, # empirical suitability
verbose = 1)
plot_biomass(ms_run, add_ci = TRUE)
################################################
# Plotting
################################################
# We can plot all runs
mod_list <- list(ss_run, ss_run_M, ms_run)
mod_names <- c("Single-species", "Single-species estimate M", "Multi-species")
# Plot biomass trajectory
plot_biomass(Rceattle = mod_list, model_names = mod_names)
plot_depletionSSB(Rceattle = mod_list, model_names = mod_names)
plot_recruitment(Rceattle = mod_list, model_names = mod_names, add_ci = TRUE)
#####################################################################
# FIX SUITABILITY AND SUM across prey ages (NEW PART)
# Create initial parameter list:
test_data<-BS2017MS
inits = ms_run$estimated_params
map = ms_run$map # gam_a, gam_b, and log_phi are turned off here
ms_run$map$mapList$log_gam_a
# Create a list prey size preference
# Set weight ratio parameters
inits$log_gam_a = c(-6.61, -3.91, -3.46)  # Mean log weight ratio
inits$log_gam_b = c(1.99, 1.69, 1.89)  # Standard deviation of log weight ratio f
test_data$diet_data$Prey_age <- -999 # Set prey age to negative values to sum across ages
a<- test_data$diet_data
head(a)
test_data_sum<- test_data$diet_data %>%
group_by(Pred, Prey, Pred_sex, Prey_sex, Pred_age, Prey_age, Year, Sample_size) %>%
summarise(Stomach_proportion_by_weight = sum(Stomach_proportion_by_weight))
head(test_data_sum)
test_data$diet_data<- test_data_sum #plug in the new data
# Set vulnerability matrix
inits$log_phi #Currently all set to 0.5 (keep it)
# Do this to estimate vulnerability (log_phi) :
map$mapList$log_phi[] <- 1:length(map$mapList$log_phi) # Unique number for each parameter
map$mapFactor$log_phi <- factor(map$mapList$log_phi)
#map$mapList$log_phi <- inits$log_phi # If we set this, the log_phi is not gonna be estimated. Should I do this or not?
#map$mapFactor$log_phi <- factor(map$mapList$log_phi) #If I do the above, then I should also do this.
#I did both and they gave different results. If we do not set #map$mapList$log_phi <- inits$log_phi , the estimated log_phi = 1.649402, and it shouldn't be above 1, right?
run_ms_LN <- Rceattle::fit_mod(data_list = test_data,
inits = inits, # Initial parameters from single species ests
map = map,
M1Fun = build_M1(M1_model = 1,
updateM1 = TRUE,
M1_use_prior = FALSE,
M2_use_prior = FALSE),
file = NULL, # Don't save
estimateMode = 0, # Estimate
niter = 3, # 3 iterations around population and predation dynamics
random_rec = FALSE, # No random recruitment
msmMode = 1, # MSVPA based
suitMode = 4, # empirical suitability
verbose = 1)
run_ms_LN$quantities$jnll_comp
run_ms_LN$data_list$Diet_weights_mcallister # Three values
run_ms_LN$quantities$vulnerability #Now it is 0.31 for all spss
## MODEL RE-Weigthing
# Access the calculated weights
run_ms_LN$data_list$Diet_comp_weights
mcallister_weights <- run_ms_LN$data_list$Diet_weights_mcallister
# Use the calculated weights for re-running
test_data$Diet_comp_weights <- run_ms_LN$data_list$Diet_weights_mcallister
inits$diet_comp_weights<- run_ms_LN$data_list$Diet_weights_mcallister #If I don't reset inits, the model give me the same mcallister weight, so I guess I have to do this so we initiate form previous mcallister weight instead of 1?
# Re-run the model with updated weights
run_ms_LN_rw <- Rceattle::fit_mod(data_list = test_data,
inits = inits, # Initial parameters from multispecies ests
map = map,
M1Fun = build_M1(M1_model = 1,
updateM1 = TRUE,
M1_use_prior = FALSE,
M2_use_prior = FALSE),
file = NULL, # Don't save
estimateMode = 0, # Estimate
niter = 3, # 3 iterations around population and predation dynamics
random_rec = FALSE, # No random recruitment
msmMode = 1, # MSVPA based
suitMode = 4, # empirical suitability
verbose = 1)
# JNLL
run_ms_LN_rw$quantities$jnll_comp ##Nothing changes
run_ms_LN_rw$quantities$vulnerability
run_ms_LN_rw$data_list$Diet_weights_mcallister #nothing changes.
run_ms_LN_rw$data_list$Diet_comp_weights #same as mcallister
# Plot
plot_biomass(list(run_ms_LN, run_ms_LN_rw), model_names = c("run_ms_LN", "run_ms_LN_rw")) ##Nothing changes
plot_b_eaten(list(run_ms_LN, run_ms_LN_rw), model_names = c("run_ms_LN", "run_ms_LN_rw")) ##Nothing changes
# We can plot all runs
mod_list <- list(ss_run, ss_run_M, ms_run, run_ms_LN_rw)
mod_names <- c("Single-species", "Single-species estimate M", "Multi-species", "run_ms_LN_rw")
# Plot biomass trajectory
plot_biomass(Rceattle = mod_list, model_names = mod_names)
plot_depletionSSB(Rceattle = mod_list, model_names = mod_names)
plot_recruitment(Rceattle = mod_list, model_names = mod_names, add_ci = TRUE)
# Plot
mod_list <- list(ms_run, run_ms_LN, run_ms_LN_rw, run_ms_LN_rw2)
## MODEL RE-Weigthing 2 ##################################################
# Access the calculated weights
run_ms_LN_rw$data_list$Diet_comp_weights
mcallister_weights <- run_ms_LN_rw$data_list$Diet_weights_mcallister
# Use the calculated weights for re-running
test_data$Diet_comp_weights <- run_ms_LN_rw$data_list$Diet_weights_mcallister #Increase for testing effect
inits$diet_comp_weights<- run_ms_LN_rw$data_list$Diet_weights_mcallister
# Re-run the model with updated weights
run_ms_LN_rw2 <- Rceattle::fit_mod(data_list = test_data,
inits = inits, # Initial parameters from multispecies ests
map = map,
M1Fun = build_M1(M1_model = 1,
updateM1 = TRUE,
M1_use_prior = FALSE,
M2_use_prior = FALSE),
file = NULL, # Don't save
estimateMode = 0, # Estimate
niter = 3, # 3 iterations around population and predation dynamics
random_rec = FALSE, # No random recruitment
msmMode = 1, # MSVPA based
suitMode = 4, # empirical suitability
verbose = 1)
# JNLL
run_ms_LN_rw2$quantities$jnll_comp ##Nothing changes
run_ms_LN_rw2$quantities$vulnerability
run_ms_LN_rw2$data_list$Diet_weights_mcallister #nothing changes.
run_ms_LN_rw2$data_list$Diet_comp_weights #same as mcallister
# Plot
mod_list <- list(ms_run, run_ms_LN, run_ms_LN_rw, run_ms_LN_rw2)
mod_names <- c("Multi-species", "Multi-species_LN", "run_ms_LN_rw", "run_ms_LN_rw2")
# Plot biomass trajectory
plot_biomass(Rceattle = mod_list, model_names = mod_names)
# Plot mortality and predation
plot_b_eaten(Rceattle = mod_list, model_names = mod_names) # Biomass eaten as prey
