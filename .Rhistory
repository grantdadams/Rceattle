}
data_list <- Rceattle::clean_data(data_list)
# Switches
data_list$random_rec <- as.numeric(random_rec)
data_list$estimateMode <- estimateMode
data_list$niter <- niter
data_list$avgnMode <- avgnMode
data_list$msmMode <- msmMode
data_list$suitMode <- as.numeric(suitMode)
data_list$minNByage <- as.numeric(minNByage)
data_list$proj_mean_rec <- proj_mean_rec
if(is.null(meanyr) & is.null(data_list$meanyr)){ # If no meanyear is provided in data or function, use end year
data_list$meanyr <- data_list$endyr
}
if(!is.null(meanyr)){ # If mean year is provided in function, override data
data_list$meanyr <- meanyr
}
# HCR Switches (make length of nspp if not)
extend_length <- function(x){
if(length(x) == data_list$nspp){ return(x)}
else {return(rep(x, data_list$nspp))}
}
data_list$HCR = HCR$HCR
data_list$DynamicHCR = HCR$DynamicHCR
if(HCR$HCR != 2){ # FsprTarget is also used for fixed F (so may be of length nflts)
data_list$FsprTarget = extend_length(HCR$FsprTarget)
}
data_list$FsprLimit = extend_length(HCR$FsprLimit)
data_list$Ptarget = extend_length(HCR$Ptarget)
data_list$Plimit = extend_length(HCR$Plimit)
data_list$Alpha = extend_length(HCR$Alpha)
data_list$Pstar = extend_length(HCR$Pstar)
data_list$Sigma = extend_length(HCR$Sigma)
data_list$QnormHCR = qnorm(data_list$Pstar, 0, data_list$Sigma)
if(data_list$HCR == 2 & estimateMode == 2){estimateMode = 4} # If projecting under constant F, run parmeters through obj only
# STEP 1 - LOAD PARAMETERS
if (is.character(inits) | is.null(inits)) {
start_par <- suppressWarnings(Rceattle::build_params(
data_list = data_list,
inits = inits
))
} else{
# inits$proj_F <- data_list$fleet_control$proj_F
start_par <- inits
}
if(verbose > 0) {message("Step 1: Parameter build complete")}
# STEP 2 - BUILD MAP
if (is.null(map)) {
map <-
suppressWarnings(build_map(data_list, start_par, debug = estimateMode > 3, random_rec = random_rec))
} else{
map <- map
}
if(verbose > 0) {message("Step 2: Map build complete")}
# STEP 3 - Get bounds
if (is.null(bounds)) {
bounds <- Rceattle::build_bounds(param_list = start_par, data_list)
} else {
bounds = bounds
}
if(verbose > 0) {message("Step 3: Param bounds complete")}
# STEP 4 - Setup random effects
random_vars <- c()
if (random_rec) {
random_vars <- c(random_vars , "rec_dev", "init_dev")
}
if(random_q){
random_vars <- c(random_vars , "ln_srv_q_dev")
}
if(random_sel){
random_vars <- c(random_vars , "ln_sel_slp_dev", "sel_inf_dev", "sel_coff_dev")
}
# Set default phasing
if(!is.null(phase)){
if(class(phase) == "character"){
if(tolower(phase) == "default"){
phase = list(
dummy = 1,
ln_pop_scalar = 4,
ln_mean_rec = 1,
ln_rec_sigma = 2,
rec_dev = 2,
init_dev = 2,
ln_sex_ratio_sigma = 3,
ln_M1 = 4,
ln_mean_F = 1,
ln_Flimit = 3,
ln_Ftarget = 3,
proj_F_prop = 1,
F_dev = 1,
ln_srv_q = 3,
# srv_q_pow = 4,
ln_srv_q_dev = 5,
ln_sigma_srv_q = 4,
ln_sigma_time_varying_srv_q = 4,
sel_coff = 3,
sel_coff_dev = 4,
ln_sel_slp = 3,
sel_inf = 3,
ln_sel_slp_dev = 5,
sel_inf_dev = 5,
ln_sigma_sel = 4,
sel_curve_pen = 4,
ln_sigma_srv_index = 2,
ln_sigma_fsh_catch = 2,
comp_weights = 4,
logH_1 = 6,
logH_1a = 6,
logH_1b = 6,
logH_2 = 6,
logH_3 = 6,
H_4 = 6,
log_gam_a = 5,
log_gam_b = 5,
log_phi = 5
)
}
}
if(class(phase) == "character"){
if(tolower(phase) != "default"){
warning("phase misspecified: please set to 'default' or list with the same order as parameters.")
}
}
}
# STEP 5 - Compile CEATTLE is providing cpp file
# - Get cpp file if not provided
TMBfilename <- "ceattle_v01_09"
# STEP 6 - Reorganize data and build model object
Rceattle:::data_check(data_list)
data_list_reorganized <- Rceattle::rearrange_dat(data_list)
data_list_reorganized = c(list(model = "ceattle_v01_09"),data_list_reorganized)
if(msmMode > 0 & data_list$HCR == 3){
data_list_reorganized$HCR = 0 # Estimate model with F = 0 for the projection if multispecies
}
# - Update comp weights, future F (if input) and F_prop from data
if(!is.null(data_list$fleet_control$Comp_weights)){
start_par$comp_weights = data_list$fleet_control$Comp_weights
}
start_par$proj_F_prop = data_list$fleet_control$proj_F_prop
nyrs_proj <- data_list$projyr - data_list$styr + 1
if(!is.null(HCR$FsprTarget) & HCR$HCR == 2){
start_par$ln_Ftarget = matrix(log(HCR$FsprTarget), nrow = data_list$nspp, ncol = nyrs_proj) # Fixed fishing mortality for projections for each species
}
# - Update M1 for inits
if(updateM1){
m1 <- array(0, dim = c(data_list$nspp, 2, max(data_list$nages, na.rm = T))) # Set up array
# Initialize from inputs
for (i in 1:nrow(data_list$M1_base)) {
sp <- as.numeric(as.character(data_list$M1_base$Species[i]))
sex <- as.numeric(as.character(data_list$M1_base$Sex[i]))
# Fill in M1 array from fixed values for each sex
if(sex == 0){ sex = c(1, 2)} # If sex = combined/both males and females, fill in both dimensions
for(j in 1:length(sex)){
m1[sp, sex[j], 1:max(data_list$nages, na.rm = T)] <- as.numeric(data_list$M1_base[i,(1:max(data_list$nages, na.rm = T)) + 2])
}
}
start_par$ln_M1 <- log(m1)
}
if(verbose > 0) {message("Step 4: Data rearranged complete")}
# STEP 7 - Set up parameter bounds
L <- c()
U <- c()
for(i in 1:length(map$mapFactor)){
if(names(map$mapFactor)[i] %!in% random_vars){ # Dont have bounds for random effects
L = c(L, unlist(bounds$lower[[i]])[which(!is.na(unlist(map$mapFactor[[i]])) & !duplicated(unlist(map$mapFactor[[i]])))])
U = c(U, unlist(bounds$upper[[i]])[which(!is.na(unlist(map$mapFactor[[i]])) & !duplicated(unlist(map$mapFactor[[i]])))])
}
}
# Dimension check
dim_check <- sapply(start_par, unlist(length)) == sapply(map$mapFactor, unlist(length))
if(sum(dim_check) != length(dim_check)){
stop(print(paste0("Map and parameter objects are not the same size for: ", names(dim_check)[which(dim_check == FALSE)])))
}
# STEP 8 - Phase hindcast
step = 5
if(!is.null(phase) & estimateMode %in% c(0,1) ){
if(verbose > 0) {message(paste0("Step ", step,": Phasing begin"))}
phase_pars <- Rceattle::TMBphase(
data = data_list_reorganized,
parameters = start_par,
map = map$mapFactor,
random = random_vars,
phases = phase,
model_name = TMBfilename,
silent = verbose != 2,
use_gradient = use_gradient,
control = control
)
start_par <- phase_pars
if(verbose > 0) {message(paste0("Step ", step,": Phasing complete - getting final estimates"))}
step = step + 1
}
# STEP 9 - Fit final hindcast model
if(estimateMode != 2){ # dont build if projection and estimating HCR parameters
if(sum(as.numeric(unlist(map$mapFactor)), na.rm = TRUE) == 0){stop("Map of length 0: all NAs")}
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
random = random_vars,
silent = verbose != 2
)
}
# -- Save objects
mod_objects <-
list(
TMBfilename = TMBfilename,
initial_params = start_par,
bounds = bounds,
map = map
)
if(verbose > 0) {message(paste0("Step ",step, ": final build complete. Optimizing."))}
step = step + 1
# -- Optimize hindcast
if(estimateMode %in% c(0,1,4)){
opt = Rceattle::fit_tmb(obj = obj,
fn=obj$fn,
gr=obj$gr,
startpar=obj$par,
lower = L,
upper = U,
loopnum = loopnum,
getsd = getsd,
control = control,
getJointPrecision = getJointPrecision,
quiet = verbose < 2,
)
if(verbose > 0) {message("Step ",step, ": Final optimization complete")
step = step + 1
}
# -- Convergence warnings
if(estimateMode %in% c(0,1)){
# Bad parameter identification
if(is.null(opt$SD) & getsd){
identified <- suppressMessages(TMBhelper::check_estimability(obj))
# Make into list
identified_param_list <- obj$env$parList(identified$BadParams$Param_check)
identified_param_list <- rapply(identified_param_list,function(x) ifelse(x==0,"Not estimated",x), how = "replace")
identified_param_list <- rapply(identified_param_list,function(x) ifelse(x==1,"OK",x), how = "replace")
identified_param_list <- rapply(identified_param_list,function(x) ifelse(x==2,"BAD",x), how = "replace")
identified$param_list <- identified_param_list
mod_objects$identified <- identified
}
}
}
# -- Get MLEs
if (estimateMode > 1) { # Debugging and projection only: use initial parameters
last_par <- start_par
} else{
if(!random_rec){
last_par = try(obj$env$parList(obj$env$last.par.best)) # FIXME: maybe add obj$env$last.par.best inside?
} else {
last_par = try(obj$env$parList())
}
}
# STEP 10 - Run HCR projections
if(estimateMode %in% c(0,2,4)){
if(data_list$HCR > 2){
# - Single species mode
if(msmMode == 0){
# -- Update map in obs
hcr_map <- build_hcr_map(data_list, map, debug = estimateMode > 3)
if(sum(as.numeric(unlist(hcr_map$mapFactor)), na.rm = TRUE) == 0){stop("HCR map of length 0: all NAs")}
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = last_par,
DLL = TMBfilename,
map = hcr_map$mapFactor,
random = random_vars,
silent = verbose != 2
)
# -- Optimize
opt = Rceattle::fit_tmb(obj = obj,
fn=obj$fn,
gr=obj$gr,
startpar=obj$par,
loopnum = loopnum,
getsd = getsd,
control = control,
getJointPrecision = FALSE,
quiet = verbose < 2,
)
}
# - Multi-species mode
if(msmMode > 0){
# -- Update map in obs
hcr_map <- build_hcr_map(data_list, map, debug = estimateMode > 3)
if(sum(as.numeric(unlist(hcr_map$mapFactor)), na.rm = TRUE) == 0){stop("HCR map of length 0: all NAs")}
# -- Get quantities
if(estimateMode == 2){ # Build obj if we havent done so already
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = last_par,
DLL = TMBfilename,
map = hcr_map$mapFactor,
random = random_vars,
silent = verbose != 2
)
}
quantities <- obj$report(obj$env$last.par.best)
# -- Get SB0: SSB when model is projected forward under no fishing
SB0 <- quantities$biomassSSB[, ncol(quantities$biomassSSB)]
B0 <- quantities$biomass[, ncol(quantities$biomass)]
data_list_reorganized$MSSB0 <- SB0
# -- Set HCR back to original
data_list_reorganized$HCR <- data_list$HCR
# --- Update model object for HCR
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = last_par,
DLL = TMBfilename,
map = hcr_map$mapFactor,
random = random_vars,
silent = verbose != 2
)
# -- Optimize
opt = Rceattle::fit_tmb(obj = obj,
fn=obj$fn,
gr=obj$gr,
startpar=obj$par,
loopnum = loopnum,
getsd = getsd,
control = control,
getJointPrecision = FALSE,
quiet = verbose < 2,
)
}
# obj$report()$DynamicSPRtarget/obj$report()$DynamicSPR0
# obj$report()$DynamicSPRlimit/obj$report()$DynamicSPR0
#
# obj$report()$SPRtarget/obj$report()$SPR0
# obj$report()$SPRlimit/obj$report()$SPR0
#
# obj$report()$SPR0
# obj$report()$SB0
if(verbose > 0) {message("Step ",step, ": Projections complete")}
# -- Update MLEs
if (estimateMode > 2) { # Debugging, give initial parameters
last_par <- start_par
}
else{
if(!random_rec){
last_par = try(obj$env$parList(obj$env$last.par.best)) # FIXME: maybe add obj$env$last.par.best inside?
} else {
last_par = try(obj$env$parList())
}
}
}
}
# - Save estimated parameters
mod_objects$estimated_params <- last_par
mod_objects$obj = obj
# - Get quantities
quantities <- obj$report(obj$env$last.par.best)
# -- Warning for discontinuous likelihood
if(estimateMode %in% c(0:2)){
if(!is.null(opt$SD) & random_rec == FALSE){
if(abs(opt$objective - quantities$jnll) > rel_tol){
message( "#########################" )
message( "Convergence warning (8)" )
message( "#########################" )
}
}
}
# -- Rename jnll
colnames(quantities$jnll_comp) <- paste0("Sp/Srv/Fsh_", 1:ncol(quantities$jnll_comp))
rownames(quantities$jnll_comp) <- c(
"Survey biomass",
"Total catch",
"Age/length composition data",
"Sex ratio",
"Non-parametric selectivity",
"Selectivity deviates",
"NA",
"Selectivity normalization",
"Catchability prior",
"Catchability deviates",
"Recruitment deviates",
"Initial abundance deviates",
"Fishing mortality deviates",
"SPR Calculation",
"Zero n-at-age penalty",
"Ration",
"Ration penalties",
"Stomach content proportion by weight"
)
colnames(quantities$biomassSSB) <- data_list$styr:data_list$projyr
colnames(quantities$R) <- data_list$styr:data_list$projyr
rownames(quantities$biomassSSB) <- data_list$spnames
rownames(quantities$R) <- data_list$spnames
# -- Save derived quantities
mod_objects$quantities <- quantities
# - Calculate Mcallister-Iannelli coefficients
# Effective sample size for the length data for year y
eff_n_mcallister <- rowSums(quantities$comp_hat * (1 - quantities$comp_hat), na.rm = TRUE)/rowSums((data_list_reorganized$comp_obs - quantities$comp_hat)^2, na.rm = TRUE) # sum_length (p_hat * (1 - p_hat))/ sum_length ((p - p_hat) ^ 2)
# Loop fleets and take harmonic mean
data_list$fleet_control$Est_weights_mcallister <- NA
for(flt in unique(data_list$comp_data$Fleet_code)){
comp_sub <- which(data_list$comp_data$Fleet_code == flt & data_list$comp_data$Year > 0)
data_list$fleet_control$Est_weights_mcallister[which(data_list$fleet_control$Fleet_code == flt)] <- ((1/length(comp_sub))*sum((eff_n_mcallister[comp_sub]/data_list$comp_data$Sample_size[comp_sub])^-1))^-1
}
# -- Save data w/ mcallister
mod_objects$data_list <- data_list
# - Save objects
mod_objects$run_time = ((Sys.time() - start_time))
if(estimateMode < 3){
mod_objects$opt = opt
mod_objects$sdrep = opt$SD
}
class(mod_objects) <- "Rceattle"
if(!is.null(file)){
save(mod_objects, file = paste0(file, ".RData"))
}
# suppressWarnings(try(dyn.unload(TMB::dynlib(paste0(cpp_file)))))
return(mod_objects)
# Free up memory
TMB::FreeADFun(obj)
}
#' Function to clean data for Rceattle runs
#'
#' @param data_list
#'
#' @export
#'
clean_data <- function(data_list){
# - Remove years of data previous to start year
data_list$UobsWtAge <- as.data.frame(data_list$UobsWtAge)
data_list$UobsAge <- as.data.frame(data_list$UobsAge)
data_list$wt <- data_list$wt[which(data_list$wt$Year == 0 | data_list$wt$Year >= data_list$styr),]
data_list$UobsAge <- data_list$UobsAge[which(data_list$UobsAge$Year == 0 | data_list$UobsAge$Year >= data_list$styr),]
data_list$UobsWtAge <- data_list$UobsWtAge[which(data_list$UobsWtAge$Year == 0 | data_list$UobsWtAge$Year >= data_list$styr),]
data_list$srv_biom <- data_list$srv_biom[which(abs(data_list$srv_biom$Year) >= data_list$styr),]
data_list$fsh_biom <- data_list$fsh_biom[which(abs(data_list$fsh_biom$Year) >= data_list$styr),]
data_list$comp_data <- data_list$comp_data[which(abs(data_list$comp_data$Year) >= data_list$styr),]
data_list$emp_sel <- data_list$emp_sel[which(data_list$emp_sel$Year == 0 | data_list$emp_sel$Year >= data_list$styr),]
data_list$NByageFixed <- data_list$NByageFixed[which(data_list$NByageFixed$Year == 0 | data_list$NByageFixed$Year >= data_list$styr),]
data_list$Pyrs <- data_list$Pyrs[which(data_list$Pyrs$Year == 0 | data_list$Pyrs$Year >= data_list$styr),]
# - Add temp multi-species SB0
data_list$MSSB0 <- rep(999, data_list$nspp)
# - Remove years of data after to proj year
data_list$wt <- data_list$wt[which(data_list$wt$Year <= data_list$projyr),]
data_list$UobsAge <- data_list$UobsAge[which(data_list$UobsAge$Year <= data_list$projyr),]
data_list$UobsWtAge <- data_list$UobsWtAge[which(data_list$UobsWtAge$Year <= data_list$projyr),]
data_list$srv_biom <- data_list$srv_biom[which(abs(data_list$srv_biom$Year) <= data_list$projyr),]
data_list$fsh_biom <- data_list$fsh_biom[which(abs(data_list$fsh_biom$Year) <= data_list$projyr),]
data_list$comp_data <- data_list$comp_data[which(abs(data_list$comp_data$Year) <= data_list$projyr),]
data_list$emp_sel <- data_list$emp_sel[which(data_list$emp_sel$Year <= data_list$projyr),]
data_list$NByageFixed <- data_list$NByageFixed[which(data_list$NByageFixed$Year <= data_list$projyr),]
data_list$Pyrs <- data_list$Pyrs[which(data_list$Pyrs$Year <= data_list$projyr),]
# - Extend catch data to proj year for projections
if(data_list$projyr > data_list$endyr){
# yrs_proj <- (data_list$endyr + 1):data_list$projyr
# proj_fsh_biom <- data_list$fsh_biom %>%
#   group_by(Fleet_code) %>%
#   slice(rep(n(),  length(yrs_proj))) %>%
#   mutate(Year = yrs_proj, Catch = NA)
# data_list$fsh_biom <- rbind(data_list$fsh_biom, proj_fsh_biom)
for(flt in (unique(data_list$fsh_biom$Fleet_code))){
fsh_biom_sub <- data_list$fsh_biom[which(data_list$fsh_biom$Fleet_code == flt),]
yrs_proj <- (data_list$endyr + 1):data_list$projyr
yrs_proj <- yrs_proj[which(yrs_proj %!in% fsh_biom_sub$Year)]
nyrs_proj <- length(yrs_proj)
proj_fsh_biom <- data.frame(Fleet_name = rep(fsh_biom_sub$Fleet_name[1], nyrs_proj),
Fleet_code = rep(flt, nyrs_proj),
Species = rep(fsh_biom_sub$Species[1], nyrs_proj),
Year = yrs_proj,
Month = rep(fsh_biom_sub$Month[length(fsh_biom_sub$Month)], nyrs_proj),
Selectivity_block = rep(fsh_biom_sub$Selectivity_block[length(fsh_biom_sub$Selectivity_block)], nyrs_proj),
Catch = rep(NA, nyrs_proj),
Log_sd = rep(fsh_biom_sub$Log_sd[length(fsh_biom_sub$Log_sd)], nyrs_proj))
data_list$fsh_biom <- rbind(data_list$fsh_biom, proj_fsh_biom)
}
}
data_list$fsh_biom <- data_list$fsh_biom[
with(data_list$fsh_biom, order(Fleet_code, Year)),]
return(data_list)
}
#' Not in function
#'
#' @param x
#' @param y
#'
#' @export
#'
'%!in%' <- function(x,y){!('%in%'(x,y))}
ss_run <- fit_mod(data_list = BS2017SS,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 1, # Estimate hindcast only
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = "default",
verbose = 1)
library(Rceattle)
library(Rceattle)
library(Rceattle)
devtools::document()
library(Rceattle)
library(Rceattle)
library(Rceattle)
library(Rceattle)
library(Rceattle)
library(Rceattle)
library(Rceattle)
library(Rceattle)
library(Rceattle)
library(Rceattle)
gc()
library(Rceattle)
devtools::document()
library(Rceattle)
