loopnum = 5;
verbose = 1;
newtonsteps = 0
proj_mean_rec = TRUE
data_list = BS2017SS
inits = ss_run$estimated_params
estimateMode = 2
HCR = build_hcr(HCR = 4, # Tier3 HCR
FsprTarget = 0.4, # F40%
FsprLimit = 0.2,
Plimit = 0.2
)
msmMode = 0
verbose = 1
start_time <- Sys.time()
setwd(getwd())
# STEP 1 - LOAD DATA
if (is.null(data_list)) {
stop("Missing data_list object")
}
data_list <- Rceattle::clean_data(data_list)
# Switches
data_list$random_rec <- as.numeric(random_rec)
data_list$estimateMode <- estimateMode
data_list$niter <- niter
data_list$avgnMode <- avgnMode
data_list$msmMode <- msmMode
data_list$suitMode <- as.numeric(suitMode)
data_list$minNByage <- as.numeric(minNByage)
data_list$proj_mean_rec <- proj_mean_rec
if(is.null(meanyr) & is.null(data_list$meanyr)){ # If no meanyear is provided in data or function, use end year
data_list$meanyr <- data_list$endyr
}
if(!is.null(meanyr)){ # If mean year is provided in function, override data
data_list$meanyr <- meanyr
}
# HCR Switches (make length of nspp if not)
extend_length <- function(x){
if(length(x) == data_list$nspp){ return(x)}
else {return(rep(x, data_list$nspp))}
}
data_list$HCR = HCR$HCR
data_list$DynamicHCR = HCR$DynamicHCR
if(HCR$HCR != 2){ # FsprTarget is also used for fixed F (so may be of length nflts)
data_list$FsprTarget = extend_length(HCR$FsprTarget)
} else {
data_list$FsprTarget = HCR$FsprTarget
}
data_list$FsprLimit = extend_length(HCR$FsprLimit)
data_list$Ptarget = extend_length(HCR$Ptarget)
data_list$Plimit = extend_length(HCR$Plimit)
data_list$Alpha = extend_length(HCR$Alpha)
data_list$Pstar = extend_length(HCR$Pstar)
data_list$Sigma = extend_length(HCR$Sigma)
data_list$QnormHCR = qnorm(data_list$Pstar, 0, data_list$Sigma)
data_list$FsprLimit
data_list$HC
if(data_list$HCR == 2 & estimateMode == 2){estimateMode = 4} # If projecting under constant F, run parmeters through obj only
# STEP 1 - LOAD PARAMETERS
if (is.character(inits) | is.null(inits)) {
start_par <- suppressWarnings(Rceattle::build_params(
data_list = data_list,
inits = inits
))
} else{
# inits$proj_F <- data_list$fleet_control$proj_F
start_par <- inits
}
if(verbose > 0) {message("Step 1: Parameter build complete")}
# STEP 2 - BUILD MAP
if (is.null(map)) {
map <-
suppressWarnings(build_map(data_list, start_par, debug = estimateMode > 3, random_rec = random_rec))
} else{
map <- map
}
if(verbose > 0) {message("Step 2: Map build complete")}
# STEP 3 - Get bounds
if (is.null(bounds)) {
bounds <- Rceattle::build_bounds(param_list = start_par, data_list)
} else {
bounds = bounds
}
if(verbose > 0) {message("Step 3: Param bounds complete")}
# STEP 4 - Setup random effects
random_vars <- c()
if (random_rec) {
random_vars <- c(random_vars , "rec_dev", "init_dev")
}
if(random_q){
random_vars <- c(random_vars , "ln_srv_q_dev")
}
if(random_sel){
random_vars <- c(random_vars , "ln_sel_slp_dev", "sel_inf_dev", "sel_coff_dev")
}
# Set default phasing
if(!is.null(phase)){
if(class(phase) == "character"){
if(tolower(phase) == "default"){
phase = list(
dummy = 1,
ln_pop_scalar = 4,
ln_mean_rec = 1,
ln_rec_sigma = 2,
rec_dev = 2,
init_dev = 2,
ln_sex_ratio_sigma = 3,
ln_M1 = 4,
ln_mean_F = 1,
ln_Flimit = 3,
ln_Ftarget = 3,
proj_F_prop = 1,
F_dev = 1,
ln_srv_q = 3,
# srv_q_pow = 4,
ln_srv_q_dev = 5,
ln_sigma_srv_q = 4,
ln_sigma_time_varying_srv_q = 4,
sel_coff = 3,
sel_coff_dev = 4,
ln_sel_slp = 3,
sel_inf = 3,
ln_sel_slp_dev = 5,
sel_inf_dev = 5,
ln_sigma_sel = 4,
sel_curve_pen = 4,
ln_sigma_srv_index = 2,
ln_sigma_fsh_catch = 2,
comp_weights = 4,
logH_1 = 6,
logH_1a = 6,
logH_1b = 6,
logH_2 = 6,
logH_3 = 6,
H_4 = 6,
log_gam_a = 5,
log_gam_b = 5,
log_phi = 5
)
}
}
if(class(phase) == "character"){
if(tolower(phase) != "default"){
warning("phase misspecified: please set to 'default' or list with the same order as parameters.")
}
}
}
# STEP 5 - Compile CEATTLE is providing cpp file
# - Get cpp file if not provided
TMBfilename <- "ceattle_v01_09"
# STEP 6 - Reorganize data and build model object
Rceattle:::data_check(data_list)
data_list_reorganized <- Rceattle::rearrange_dat(data_list)
data_list_reorganized = c(list(model = "ceattle_v01_09"),data_list_reorganized)
if(msmMode > 0 & data_list$HCR == 3){
data_list_reorganized$HCR = 0 # Estimate model with F = 0 for the projection if multispecies
}
# - Update comp weights, future F (if input) and F_prop from data
if(!is.null(data_list$fleet_control$Comp_weights)){
start_par$comp_weights = data_list$fleet_control$Comp_weights
}
start_par$proj_F_prop = data_list$fleet_control$proj_F_prop
nyrs_proj <- data_list$projyr - data_list$styr + 1
if(!is.null(HCR$FsprTarget) & HCR$HCR == 2){
start_par$ln_Ftarget = matrix(log(HCR$FsprTarget), nrow = data_list$nspp, ncol = nyrs_proj) # Fixed fishing mortality for projections for each species
}
# - Update M1 for inits
if(updateM1){
m1 <- array(0, dim = c(data_list$nspp, 2, max(data_list$nages, na.rm = T))) # Set up array
# Initialize from inputs
for (i in 1:nrow(data_list$M1_base)) {
sp <- as.numeric(as.character(data_list$M1_base$Species[i]))
sex <- as.numeric(as.character(data_list$M1_base$Sex[i]))
# Fill in M1 array from fixed values for each sex
if(sex == 0){ sex = c(1, 2)} # If sex = combined/both males and females, fill in both dimensions
for(j in 1:length(sex)){
m1[sp, sex[j], 1:max(data_list$nages, na.rm = T)] <- as.numeric(data_list$M1_base[i,(1:max(data_list$nages, na.rm = T)) + 2])
}
}
start_par$ln_M1 <- log(m1)
}
if(verbose > 0) {message("Step 4: Data rearranged complete")}
# STEP 7 - Set up parameter bounds
L <- c()
U <- c()
for(i in 1:length(map$mapFactor)){
if(names(map$mapFactor)[i] %!in% random_vars){ # Dont have bounds for random effects
L = c(L, unlist(bounds$lower[[i]])[which(!is.na(unlist(map$mapFactor[[i]])) & !duplicated(unlist(map$mapFactor[[i]])))])
U = c(U, unlist(bounds$upper[[i]])[which(!is.na(unlist(map$mapFactor[[i]])) & !duplicated(unlist(map$mapFactor[[i]])))])
}
}
# Dimension check
dim_check <- sapply(start_par, unlist(length)) == sapply(map$mapFactor, unlist(length))
if(sum(dim_check) != length(dim_check)){
stop(print(paste0("Map and parameter objects are not the same size for: ", names(dim_check)[which(dim_check == FALSE)])))
}
# STEP 8 - Phase hindcast
step = 5
if(!is.null(phase) & estimateMode %in% c(0,1) ){
if(verbose > 0) {message(paste0("Step ", step,": Phasing begin"))}
phase_pars <- Rceattle::TMBphase(
data = data_list_reorganized,
parameters = start_par,
map = map$mapFactor,
random = random_vars,
phases = phase,
model_name = TMBfilename,
silent = verbose != 2,
use_gradient = use_gradient,
control = control
)
start_par <- phase_pars
if(verbose > 0) {message(paste0("Step ", step,": Phasing complete - getting final estimates"))}
step = step + 1
}
estimateMode
# STEP 9 - Fit final hindcast model
if(estimateMode != 2){ # dont build if projection and estimating HCR parameters
if(sum(as.numeric(unlist(map$mapFactor)), na.rm = TRUE) == 0){stop("Map of length 0: all NAs")}
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
random = random_vars,
silent = verbose != 2
)
}
# -- Save objects
mod_objects <-
list(
TMBfilename = TMBfilename,
initial_params = start_par,
bounds = bounds,
map = map
)
if(verbose > 0) {message(paste0("Step ",step, ": final build complete. Optimizing."))}
step = step + 1
# -- Optimize hindcast
if(estimateMode %in% c(0,1,4)){
opt = Rceattle::fit_tmb(obj = obj,
fn=obj$fn,
gr=obj$gr,
startpar=obj$par,
lower = L,
upper = U,
loopnum = loopnum,
getsd = getsd,
control = control,
getJointPrecision = getJointPrecision,
quiet = verbose < 2,
)
if(verbose > 0) {message("Step ",step, ": Final optimization complete")
step = step + 1
}
# -- Convergence warnings
if(estimateMode %in% c(0,1)){
# Bad parameter identification
if(is.null(opt$SD) & getsd){
identified <- suppressMessages(TMBhelper::check_estimability(obj))
# Make into list
identified_param_list <- obj$env$parList(identified$BadParams$Param_check)
identified_param_list <- rapply(identified_param_list,function(x) ifelse(x==0,"Not estimated",x), how = "replace")
identified_param_list <- rapply(identified_param_list,function(x) ifelse(x==1,"OK",x), how = "replace")
identified_param_list <- rapply(identified_param_list,function(x) ifelse(x==2,"BAD",x), how = "replace")
identified$param_list <- identified_param_list
mod_objects$identified <- identified
}
}
}
# -- Get MLEs
if (estimateMode > 1) { # Debugging and projection only: use initial parameters
last_par <- start_par
} else{
if(!random_rec){
last_par = try(obj$env$parList(obj$env$last.par.best)) # FIXME: maybe add obj$env$last.par.best inside?
} else {
last_par = try(obj$env$parList())
}
}
data_list$HCR
msmMode
# -- Update map in obs
hcr_map <- build_hcr_map(data_list, map, debug = estimateMode > 3)
hcr_map$mapList$ln_Flimit
#' Function to construct the TMB map argument for CEATTLE for projecting under alternative harvest control rules
#'
#' @description Reads a data list and map to update the map argument based on the HCR specified in \code{\link{build_hcr}}
#'
#' @param data_list a data_list created from \code{\link{build_dat}}.
#' @param map a map object created from \code{\link{build_map}}.
#' @param TRUE/FALSE map out all parameters
#'
#' @return a list of map arguments for each parameter
#' @export
build_hcr_map <- function(data_list, map, debug = FALSE){
# Step 1 - Turn off all population/fleet parameters and turn on Fspr parameters
map$mapList = sapply(map$mapList, function(x) replace(x, values = rep(NA, length(x))))
yrs_proj = data_list$endyr:data_list$projyr - data_list$styr
# Step 2 - Turn on Fspr parameters depending on HCR
# -- HCR = 0: No catch - Params off
# -- HCR = 1: Constant catch - Params off
# -- HCR = 2: Constant input F - Params off
# -- HCR = 3: F that acheives X% of SSB0 in the end of the projection - Ftarget on
# -- HCR = 4: Constant target Fspr - Ftarget on
# -- HCR = 5: NPFMC Tier 3 - Flimit and Ftarget on
# -- HCR = 6: PFMC Cat 1 - Flimit on
# -- HCR = 7: SESSF Tier 1 - Flimit and Ftarget on
# --- Dynamic BRPS - 1 value per species and year
if(!debug){
if(data_list$DynamicHCR){
if(data_list$HCR %in% c(3)){
map$mapList$ln_Ftarget <- replace(map$mapList$ln_Ftarget, values = c(1:length(map$mapList$ln_Ftarget)))
map$mapList$ln_Flimit[,1] <- NA # Initial abundance
map$mapList$ln_Ftarget[,1] <- NA # Initial abundance
}
if(data_list$HCR %in% c(4)){
warning("No dynamic Fspr")
map$mapList$ln_Ftarget <- replace(map$mapList$ln_Ftarget, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Ftarget)))
map$mapList$ln_Flimit <- replace(map$mapList$ln_Flimit, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Flimit)))
map$mapList$ln_Flimit[,1] <- NA # Initial abundance
map$mapList$ln_Ftarget[,1] <- NA # Initial abundance
}
if(data_list$HCR %in% c(5,7)){
map$mapList$ln_Ftarget <- replace(map$mapList$ln_Ftarget, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Ftarget)))
map$mapList$ln_Flimit <- replace(map$mapList$ln_Flimit, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Flimit)))
}
if(data_list$HCR == 6){
map$mapList$ln_Flimit <- replace(map$mapList$ln_Flimit, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Flimit)))
}
}
# --- Static BRPS - 1 value per species
if(data_list$DynamicHCR == FALSE){
if(data_list$HCR %in% c(3,4)){
map$mapList$ln_Ftarget <- replace(map$mapList$ln_Ftarget, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Ftarget)))
}
if(data_list$HCR %in% c(5,7)){
map$mapList$ln_Ftarget <- replace(map$mapList$ln_Ftarget, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Ftarget)))
map$mapList$ln_Flimit <- replace(map$mapList$ln_Flimit, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Flimit)))
}
if(data_list$HCR == 6){
map$mapList$ln_Flimit <- replace(map$mapList$ln_Flimit, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Flimit)))
}
}
# Step 3 - Turn off SPR parameters for special cases
# -- Turn off SPR parameters for species with no fishing (sum(proj_F_prop) == 0)
# -- Turn off SPR parameters for species with fixed Nbyage
for(sp in 1:data_list$nspp){
# Check proj F if proj F prop is all 0
prop_check <- data_list$fleet_control$proj_F_prop[which(data_list$fleet_control$Species == sp & data_list$fleet_control$Fleet_type == 1)]
if(sum(as.numeric(prop_check == 0)) != 0){ # If all fisheries for a species have no F in F_prop, turn off future F
print(paste("F_prop for species",sp,"sums to 0"))
map$mapList$ln_Ftarget[sp,] <- NA
map$mapList$ln_Flimit[sp,] <- NA
}
# Fixed n-at-age: Turn off parameters
if(data_list$estDynamics[sp] > 0){
map$mapList$ln_Ftarget[sp,] <- NA
map$mapList$ln_Flimit[sp,] <- NA
}
}
}
if(debug){
map$mapList$dummy = 1
}
# STEP 5 -- Convert to factor
map$mapFactor <- sapply(map$mapList, factor)
return(map)
}
# -- Update map in obs
hcr_map <- build_hcr_map(data_list, map, debug = estimateMode > 3)
hcr_map$mapList$ln_Flimit
debug = estimateMode > 3
map
debug
# Step 1 - Turn off all population/fleet parameters and turn on Fspr parameters
map$mapList = sapply(map$mapList, function(x) replace(x, values = rep(NA, length(x))))
yrs_proj = data_list$endyr:data_list$projyr - data_list$styr
debug
data_list$DynamicHCR
# -- Update map in obs
hcr_map <- build_hcr_map(data_list, map, debug = estimateMode > 3)
hcr_map$mapList$ln_Flimit
# -- Update map in obs
hcr_map <- build_hcr_map(data_list, map, debug = estimateMode > 3)
#' Function to construct the TMB map argument for CEATTLE for projecting under alternative harvest control rules
#'
#' @description Reads a data list and map to update the map argument based on the HCR specified in \code{\link{build_hcr}}
#'
#' @param data_list a data_list created from \code{\link{build_dat}}.
#' @param map a map object created from \code{\link{build_map}}.
#' @param TRUE/FALSE map out all parameters
#'
#' @return a list of map arguments for each parameter
#' @export
build_hcr_map <- function(data_list, map, debug = FALSE){
# Step 1 - Turn off all population/fleet parameters and turn on Fspr parameters
map$mapList = sapply(map$mapList, function(x) replace(x, values = rep(NA, length(x))))
yrs_proj = data_list$endyr:data_list$projyr - data_list$styr
# Step 2 - Turn on Fspr parameters depending on HCR
# -- HCR = 0: No catch - Params off
# -- HCR = 1: Constant catch - Params off
# -- HCR = 2: Constant input F - Params off
# -- HCR = 3: F that acheives X% of SSB0 in the end of the projection - Ftarget on
# -- HCR = 4: Constant target Fspr - Ftarget on
# -- HCR = 5: NPFMC Tier 3 - Flimit and Ftarget on
# -- HCR = 6: PFMC Cat 1 - Flimit on
# -- HCR = 7: SESSF Tier 1 - Flimit and Ftarget on
# --- Dynamic BRPS - 1 value per species and year
if(!debug){
# - Dynamic HCR
if(data_list$DynamicHCR){
if(data_list$HCR %in% c(3)){
map$mapList$ln_Ftarget <- replace(map$mapList$ln_Ftarget, values = c(1:length(map$mapList$ln_Ftarget)))
map$mapList$ln_Flimit[,1] <- NA # Initial abundance
map$mapList$ln_Ftarget[,1] <- NA # Initial abundance
}
if(data_list$HCR %in% c(4)){
warning("No dynamic Fspr")
map$mapList$ln_Ftarget <- replace(map$mapList$ln_Ftarget, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Ftarget)))
map$mapList$ln_Flimit <- replace(map$mapList$ln_Flimit, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Flimit)))
map$mapList$ln_Flimit[,1] <- NA # Initial abundance
map$mapList$ln_Ftarget[,1] <- NA # Initial abundance
}
if(data_list$HCR %in% c(5,7)){
map$mapList$ln_Ftarget <- replace(map$mapList$ln_Ftarget, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Ftarget)))
map$mapList$ln_Flimit <- replace(map$mapList$ln_Flimit, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Flimit)))
}
if(data_list$HCR == 6){
map$mapList$ln_Flimit <- replace(map$mapList$ln_Flimit, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Flimit)))
}
}
# --- Static BRPS - 1 value per species
if(data_list$DynamicHCR == FALSE){
if(data_list$HCR %in% c(3,4)){
map$mapList$ln_Ftarget <- replace(map$mapList$ln_Ftarget, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Ftarget)))
map$mapList$ln_Flimit <- replace(map$mapList$ln_Flimit, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Flimit)))
}
if(data_list$HCR %in% c(5,7)){
map$mapList$ln_Ftarget <- replace(map$mapList$ln_Ftarget, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Ftarget)))
map$mapList$ln_Flimit <- replace(map$mapList$ln_Flimit, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Flimit)))
}
if(data_list$HCR == 6){
map$mapList$ln_Flimit <- replace(map$mapList$ln_Flimit, values = rep(1:data_list$nspp, ncol(map$mapList$ln_Flimit)))
}
}
# Step 3 - Turn off SPR parameters for special cases
# -- Turn off SPR parameters for species with no fishing (sum(proj_F_prop) == 0)
# -- Turn off SPR parameters for species with fixed Nbyage
for(sp in 1:data_list$nspp){
# Check proj F if proj F prop is all 0
prop_check <- data_list$fleet_control$proj_F_prop[which(data_list$fleet_control$Species == sp & data_list$fleet_control$Fleet_type == 1)]
if(sum(as.numeric(prop_check == 0)) != 0){ # If all fisheries for a species have no F in F_prop, turn off future F
print(paste("F_prop for species",sp,"sums to 0"))
map$mapList$ln_Ftarget[sp,] <- NA
map$mapList$ln_Flimit[sp,] <- NA
}
# Fixed n-at-age: Turn off parameters
if(data_list$estDynamics[sp] > 0){
map$mapList$ln_Ftarget[sp,] <- NA
map$mapList$ln_Flimit[sp,] <- NA
}
}
}
if(debug){
map$mapList$dummy = 1
}
# STEP 5 -- Convert to factor
map$mapFactor <- sapply(map$mapList, factor)
return(map)
}
# -- Update map in obs
hcr_map <- build_hcr_map(data_list, map, debug = estimateMode > 3)
hcr_map$mapList$ln_Flimit
library(Rceattle)
library(Rceattle)
library(dplyr)
################################################
# Data
################################################
# Example
# To run the 2017 single species assessment for the Bering Sea, a data file must first be loaded:
data(BS2017SS) # ?BS2017SS for more information on the data
BS2017SS$projyr <- 2060
################################################
# Estimation
################################################
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
BS2017SS$fleet_control$proj_F_prop <-rep(1,7)
ss_run <- Rceattle::fit_mod(data_list = BS2017SS,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 1, # Estimate hindcast only
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = "default",
verbose = 1)
# -- Constant Fspr
ss_run_Fspr <- Rceattle::fit_mod(data_list = BS2017SS,
inits = ss_run$estimated_params, # Initial parameters from ss_run
estimateMode = 2, # Run projection only
HCR = build_hcr(HCR = 4, # Tier3 HCR
FsprTarget = 0.4, # F40%
FsprLimit = 0.2,
Plimit = 0.2
),
msmMode = 0, # Single species mode
verbose = 1)
ss_run_Fspr$quantities$Flimit
ss_run_Fspr$quantities$Ftarget
library(Rceattle)
library(Rceattle)
