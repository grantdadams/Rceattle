# Horizontal line at end yr
if(incl_proj){
abline(v = max_endyr, lwd  = lwd, col = "grey", lty = 2)
}
# Legends
legend("topleft",
legend = spnames[spp[j]],
bty = "n",
cex = 1)
if(!is.null(mohns)){
legend("top", paste0("Rho = ", round(mohns[3,spp[j]+1], 2) ), bty = "n", cex = 0.8) # Biomass rho
}
if (spp[j] == 1) {
if(!is.null(model_names)){
legend(
"topright",
legend = model_names,
lty = rep(1, length(line_col)),
lwd = lwd,
col = line_col,
bty = "n",
cex = 0.72
)
}
}
# Credible interval
if (add_ci) {
for (k in 1:dim(recruitment)[3]) {
polygon(
x = c(Years[[k]], rev(Years[[k]])),
y = c(recruitment_upper[spp[j], 1:length(Years[[k]]), k], rev(recruitment_lower[spp[j], 1:length(Years[[k]]), k])),
col = adjustcolor( line_col[k], alpha.f = 0.4),
border = NA
) # 95% CI
}
}
# Mean recruitment
for (k in 1:dim(recruitment)[3]) {
lines(
x = Years[[k]],
y = recruitment[spp[j], 1:length(Years[[k]]), k],
lty = 1,
lwd = lwd,
col = line_col[k]
) # Median
}
}
if (i == 2) {
dev.off()
}
}
}
plot_recruitment(Rceattle, add_ci = TRUE)
sd_rec <- which(names(Rceattle[[i]]$sdrep$value) == "R")
sd_rec <- Rceattle[[i]]$sdrep$sd[sd_rec]
recruitment_sd[, , i] <-
replace(recruitment_sd[, , i], values = sd_rec[1:(nyrs_vec[i] * nspp)])
i
sd_rec[1:(nyrs_vec[i] * nspp)]
length(sd_rec[1:(nyrs_vec[i] * nspp)])
length(recruitment_sd[, , i])
i = 1
# Years
sub_rel_proj_yrs <- (max_styr - Rceattle[[i]]$data_list$styr + 1) : (min_projyr - Rceattle[[i]]$data_list$styr + 1) # Find years of overlap
# Extract Rec, SSB, B
# - R
sd_rec <- array(NA, dim = c(nspp, nyrs[i]))
mu_rec <- array(NA, dim = c(nspp, nyrs[i]))
rec_rows <- which(names(Rceattle[[i]]$sdrep$value) == "R")
sd_rec <- replace(sd_rec, values = Rceattle[[i]]$sdrep$sd[rec_rows])[,sub_rel_proj_yrs]
mu_rec <- replace(mu_rec, values = Rceattle[[i]]$sdrep$value[rec_rows])[,sub_rel_proj_yrs]
# Convert single one into a list
if(class(Rceattle) == "Rceattle"){
stop("Only one model provided")
}
if(is.null(weights)){
weights = rep(1/length(Rceattle), length(Rceattle))
}
weights <- weights/sum(weights)
# Extract number of species of each model
nspp <- sapply(Rceattle, function(x) x$data_list$nspp)
nspp <- unique(nspp)
if(length(nspp) > 1){stop("Number of species does not match across models")}
# Extract timespan of each model
years <- sapply(Rceattle, function(x) x$data_list$styr:x$data_list$projyr)
endyrs <- sapply(Rceattle, function(x) x$data_list$endyr)
styrs <- sapply(Rceattle, function(x) x$data_list$styr)
projyrs <- sapply(Rceattle, function(x) x$data_list$projyr)
nyrs <- sapply(years, length)
min_projyr <- min(projyrs, na.rm = TRUE) # Find coverage across all models
min_hindyr <- min(endyrs, na.rm = TRUE) # Find coverage across all models
max_styr <- max(styrs, na.rm = TRUE)
# Initialize model average object
mod_avg <- Rceattle[[which(nyrs == min(nyrs))[1]]] # Copy a model of the smallest length to fill in
mod_avg_rel_proj_yrs <- (max_styr - mod_avg$data_list$styr + 1) : (min_projyr - mod_avg$data_list$styr + 1) # Find years of overlap
mod_avg_rel_hind_yrs <- (max_styr - mod_avg$data_list$styr + 1) : (min_hindyr - mod_avg$data_list$styr + 1) # Find years of overlap
mod_avg$estimated_params <- mod_avg$initial_params <- mod_avg$opt <- mod_avg$run_time <- mod_avg$obj <- mod_avg$map <- mod_avg$bounds <- NULL
# -- Set all quantities to zero
for(i in 1:length(mod_avg$quantities)){
mod_avg$quantities[[i]] <- replace(mod_avg$quantities[[i]], values = rep(0, length(mod_avg$quantities[[i]])))
}
weights <- round(weights * nboot)
nrows <- 1:sum(weights)
rowid <- rep(1:length(weights), weights)
# List to save samples of SSB, B, and R
recruitment <-
array(NA, dim = c(nspp, length(mod_avg_rel_proj_yrs),  sum(weights)))
biomassSSB <-
array(NA, dim = c(nspp, length(mod_avg_rel_proj_yrs),  sum(weights)))
biomass <-
array(NA, dim = c(nspp, length(mod_avg_rel_proj_yrs),  sum(weights)))
weights
# Years
sub_rel_proj_yrs <- (max_styr - Rceattle[[i]]$data_list$styr + 1) : (min_projyr - Rceattle[[i]]$data_list$styr + 1) # Find years of overlap
length(Rceattle)
i
i = 1
# Years
sub_rel_proj_yrs <- (max_styr - Rceattle[[i]]$data_list$styr + 1) : (min_projyr - Rceattle[[i]]$data_list$styr + 1) # Find years of overlap
# Extract Rec, SSB, B
# - R
sd_rec <- array(NA, dim = c(nspp, nyrs[i]))
mu_rec <- array(NA, dim = c(nspp, nyrs[i]))
rec_rows <- which(names(Rceattle[[i]]$sdrep$value) == "R")
sd_rec <- replace(sd_rec, values = Rceattle[[i]]$sdrep$sd[rec_rows])[,sub_rel_proj_yrs]
mu_rec <- replace(mu_rec, values = Rceattle[[i]]$sdrep$value[rec_rows])[,sub_rel_proj_yrs]
rec_samples <- MASS::mvrnorm(weights[i], mu = mu_rec, Sigma = diag(sd_rec))
mu_rec
rec_samples <- MASS::mvrnorm(weights[i], mu = c(mu_rec), Sigma = c(diag(sd_rec)))
diag(sd_rec)
sd_rec
rec_samples <- MASS::mvrnorm(weights[i], mu = c(mu_rec), Sigma = diag(c(sd_rec)))
rec_samples
diag(c(sd_rec))
nyrs_vec
weights[i]
weights <- weights * 10
nrows <- 1:sum(weights)
rowid <- rep(1:length(weights), weights)
# List to save samples of SSB, B, and R
recruitment <-
array(NA, dim = c(nspp, length(mod_avg_rel_proj_yrs),  sum(weights)))
biomassSSB <-
array(NA, dim = c(nspp, length(mod_avg_rel_proj_yrs),  sum(weights)))
biomass <-
array(NA, dim = c(nspp, length(mod_avg_rel_proj_yrs),  sum(weights)))
i
# Years
sub_rel_proj_yrs <- (max_styr - Rceattle[[i]]$data_list$styr + 1) : (min_projyr - Rceattle[[i]]$data_list$styr + 1) # Find years of overlap
# Extract Rec, SSB, B
# - R
sd_rec <- array(NA, dim = c(nspp, nyrs[i]))
mu_rec <- array(NA, dim = c(nspp, nyrs[i]))
rec_rows <- which(names(Rceattle[[i]]$sdrep$value) == "R")
sd_rec <- replace(sd_rec, values = Rceattle[[i]]$sdrep$sd[rec_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
mu_rec <- replace(mu_rec, values = Rceattle[[i]]$sdrep$value[rec_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
samples_rec <- MASS::mvrnorm(weights[i], mu = c(mu_rec), Sigma = diag(c(sd_rec)))
# - B
sd_biomass <- array(NA, dim = c(nspp, nyrs[i]))
mu_biomass <- array(NA, dim = c(nspp, nyrs[i]))
biomass_rows <- which(names(Rceattle[[i]]$sdrep$value) == "biomass")
sd_biomass <- replace(sd_biomass, values = Rceattle[[i]]$sdrep$sd[biomass_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
mu_biomass <- replace(mu_biomass, values = Rceattle[[i]]$sdrep$value[biomass_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
samples_biomass <- MASS::mvrnorm(weights[i], mu = c(mu_biomass), Sigma = diag(c(sd_biomass)))
# - SSB
sd_biomassSSB <- array(NA, dim = c(nspp, nyrs[i]))
mu_biomassSSB <- array(NA, dim = c(nspp, nyrs[i]))
ssb_rows <- which(names(Rceattle[[i]]$sdrep$value) == "biomassSSB")
sd_biomassSSB <- replace(sd_biomassSSB, values = Rceattle[[i]]$sdrep$sd[ssb_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
mu_biomassSSB <- replace(mu_biomassSSB, values = Rceattle[[i]]$sdrep$value[ssb_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
samples_biomassSSB <- MASS::mvrnorm(weights[i], mu = c(mu_biomassSSB), Sigma = diag(c(sd_biomassSSB)))
# Extract R, B, and SSB and assign to objects
recruitment[1:nspp, 1:length(mod_avg_rel_proj_yrs), nrows[which(rowid == i)]] <- samples_rec
biomassSSB[1:nspp, 1:length(mod_avg_rel_proj_yrs), nrows[which(rowid == i)]] <- samples_biomass
biomass[1:nspp, 1:length(mod_avg_rel_proj_yrs), nrows[which(rowid == i)]] <- samples_biomassSSB
recruitment[,,1]
recruitment[,1,]
recruitment[1,,]
head(samples_rec)
# Extract R, B, and SSB and assign to objects
recruitment[1:nspp, 1:length(mod_avg_rel_proj_yrs), nrows[which(rowid == i)]] <- c(samples_rec)
recruitment[,,1]
samples_biomassSSB
mu_biomassSSB
Rceattle[[i]]$sdrep$value[ssb_rows]
c(mu_biomassSSB)
samples_biomassSSB
colMeans(samples_biomassSSB)
c(mu_biomassSSB)
nboot
weights
weights <- round(weights * nboot)
nrows <- 1:sum(weights)
rowid <- rep(1:length(weights), weights)
# List to save samples of SSB, B, and R
samples_rec <- list()
samples_biomassSSB <- list()
samples_biomass <- list()
# Loop across models
for(i in 1:length(Rceattle)){
# Years
sub_rel_proj_yrs <- (max_styr - Rceattle[[i]]$data_list$styr + 1) : (min_projyr - Rceattle[[i]]$data_list$styr + 1) # Find years of overlap
# Extract Rec, SSB, B
# - R
sd_rec <- array(NA, dim = c(nspp, nyrs[i]))
mu_rec <- array(NA, dim = c(nspp, nyrs[i]))
rec_rows <- which(names(Rceattle[[i]]$sdrep$value) == "R")
sd_rec <- replace(sd_rec, values = Rceattle[[i]]$sdrep$sd[rec_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
mu_rec <- replace(mu_rec, values = Rceattle[[i]]$sdrep$value[rec_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
samples_rec[[i]] <- MASS::mvrnorm(weights[i], mu = c(mu_rec), Sigma = diag(c(sd_rec)))
# - B
sd_biomass <- array(NA, dim = c(nspp, nyrs[i]))
mu_biomass <- array(NA, dim = c(nspp, nyrs[i]))
biomass_rows <- which(names(Rceattle[[i]]$sdrep$value) == "biomass")
sd_biomass <- replace(sd_biomass, values = Rceattle[[i]]$sdrep$sd[biomass_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
mu_biomass <- replace(mu_biomass, values = Rceattle[[i]]$sdrep$value[biomass_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
samples_biomass[[i]] <- MASS::mvrnorm(weights[i], mu = c(mu_biomass), Sigma = diag(c(sd_biomass)))
# - SSB
sd_biomassSSB <- array(NA, dim = c(nspp, nyrs[i]))
mu_biomassSSB <- array(NA, dim = c(nspp, nyrs[i]))
ssb_rows <- which(names(Rceattle[[i]]$sdrep$value) == "biomassSSB")
sd_biomassSSB <- replace(sd_biomassSSB, values = Rceattle[[i]]$sdrep$sd[ssb_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
mu_biomassSSB <- replace(mu_biomassSSB, values = Rceattle[[i]]$sdrep$value[ssb_rows])[,sub_rel_proj_yrs] # Remove years not shared across models
samples_biomassSSB[[i]] <- MASS::mvrnorm(weights[i], mu = c(mu_biomassSSB), Sigma = diag(c(sd_biomassSSB)))
}
samples_biomassSSB[[i]]
sapply(samples_biomassSSB, dim)
# - Save samples
mod_avg$asymptotic_samples <- list(recruitment = do.call(cbind, samples_rec),
biomassSSB = do.call(cbind, samples_biomassSSB),
biomass = do.call(cbind, samples_biomass))
mod_avg$asymptotic_samples$recruitment
dim(mod_avg$asymptotic_samples)
sapply(samples_rec, dim)
# - Save samples
mod_avg$asymptotic_samples <- list(recruitment = do.call(rbind, samples_rec),
biomassSSB = do.call(rbind, samples_biomassSSB),
biomass = do.call(rbind, samples_biomass))
mod_avg$asymptotic_samples$recruitment
# - Calculate SD
# -- R
rec_rows <- which(names(mod_avg$sdrep$value) == "R")
mod_avg$sdrep$sd[rec_rows] <- sqrt(sapply(mod_avg$asymptotic_samples$recruitment, var))
mod_avg$sdrep$value[rec_rows] <- colMeans(mod_avg$asymptotic_samples$recruitment)
# -- B
biomass_rows <- which(names(mod_avg$sdrep$value) == "biomass")
mod_avg$sdrep$sd[biomass_rows] <- sqrt(sapply(mod_avg$asymptotic_samples$biomass, var))
mod_avg$sdrep$value[biomass_rows] <- colMeans(mod_avg$asymptotic_samples$biomass)
# -- SSB
ssb_rows <- which(names(mod_avg$sdrep$value) == "biomassSSB")
sqrt(sapply(mod_avg$asymptotic_samples$biomassSSB, var))
sapply(mod_avg$asymptotic_samples$biomassSSB, var)
dim(od_avg$asymptotic_samples$biomassSSB)
dim(mod_avg$asymptotic_samples$biomassSSB)
sapply(mod_avg$asymptotic_samples$biomassSSB, 2, var)
mod_avg$sdrep$sd[ssb_rows] <- sqrt(apply(mod_avg$asymptotic_samples$biomassSSB, 2, var))
sqrt(apply(mod_avg$asymptotic_samples$biomassSSB, 2, var))
# - Calculate SD
# -- R
rec_rows <- which(names(mod_avg$sdrep$value) == "R")
mod_avg$sdrep$sd[rec_rows] <- sqrt(apply(mod_avg$asymptotic_samples$recruitment, 2, var))
mod_avg$sdrep$value[rec_rows] <- colMeans(mod_avg$asymptotic_samples$recruitment)
# -- B
biomass_rows <- which(names(mod_avg$sdrep$value) == "biomass")
mod_avg$sdrep$sd[biomass_rows] <- sqrt(apply(mod_avg$asymptotic_samples$biomass, 2, var))
mod_avg$sdrep$value[biomass_rows] <- colMeans(mod_avg$asymptotic_samples$biomass)
# -- SSB
ssb_rows <- which(names(mod_avg$sdrep$value) == "biomassSSB")
mod_avg$sdrep$sd[ssb_rows] <- sqrt(apply(mod_avg$asymptotic_samples$biomassSSB, 2, var))
mod_avg$sdrep$value[ssb_rows] <- colMeans(mod_avg$asymptotic_samples$biomassSSB)
mod_avg$sdrep$sd[ssb_rows]
setwd("~/GitHub/Rceattle")
devtools::document()
devtools::document()
devtools::document()
library(Rceattle)
library(Rceattle)
devtools::document()
library(Rceattle)
devtools::document()
setwd("~/GitHub/Rceattle")
devtools::document()
devtools::document()
library(Rceattle)
load("~/GitHub/RceattleRuns/GOA/Model runs/GOA_18.5.1/Models/Random_effects_models_3iter_w_hessian/18_5_1_re_3iter_Mod_2_2021-08-23.Rdata")
mod_list <- list(mod_re)
load("~/GitHub/RceattleRuns/GOA/Model runs/GOA_18.5.1/Models/Random_effects_models_3iter_w_hessian/18_5_1_re_3iter_Mod_1_2021-08-21.Rdata")
mod_list <- c(mod_list, list(mod_re))
sapply(mod_list, function(x) x$sdrep$JointPrecision)
sapply(mod_list, function(x) x$sdrep$jointPrecision)
sapply(mod_list, function(x) !is.null(x$sdrep$jointPrecision))
sapply(mod_list, function(x) is.null(x$sdrep$jointPrecision))
sum(sapply(mod_list, function(x) is.null(x$sdrep$jointPrecision)) > 0)
# Assuming asymptotic multivariate normal
# - Must have estimated joint precision matrix
joint_est <- sapply(mod_list, function(x) is.null(x$sdrep$jointPrecision)
if(sum() > 0)){
stop()
}
# Assuming asymptotic multivariate normal
# - Must have estimated joint precision matrix
joint_est <- sapply(mod_list, function(x) is.null(x$sdrep$jointPrecision))
joint_est
Rceattle = mod_list
# Assuming asymptotic multivariate normal
# - Must have estimated joint precision matrix
joint_est <- sapply(Rceattle, function(x) is.null(x$sdrep$jointPrecision))
if(sum(joint_est) > 0){
stop(paste("Model(s):", which(joint_est > 0)," do not have joint precision matrices: re-estimate with getJointPrecision = TRUE"))
}
# List to save samples of SSB, B, and R
recruitment <-
array(NA, dim = c(nspp, length(mod_avg_rel_proj_yrs),  sum(weights)))
i = 1
# - Sample parameters from asymptotic normal distribution
fixed_mle <- Rceattle[[i]]$opt$par
# - Sample parameters from asymptotic normal distribution
mle <- Rceattle[[i]]$opt$par
vcov <- Rceattle[[i]]$sdrep$jointPrecision
vcov
rownames(vcov)
# - Sample parameters from asymptotic normal distribution
mle <- Rceattle[[i]]$opt$par
names(mle)
names(mle) == rownames(vcov)
length(mle)
# - Sample parameters from asymptotic normal distribution
mle <- Rceattle[[i]]$obj$env$last.par.best
length(mle)
names(mle) == rownames(vcov)
vcov[1,1]
?sdrep
library(TMB)
?sdreport
vcov <- solve(Rceattle[[i]]$sdrep$jointPrecision) # names(mle) == rownames(vcov)
weights[i]
weights = c(100,100)
samples <- MASS::mvrnorm(weights[i], mu = mle, Sigma = vcov)
weights = c(10,10)
# - Sample parameters from asymptotic normal distribution
mle <- Rceattle[[i]]$obj$env$last.par.best # Includes fixed and random
vcov <- solve(Rceattle[[i]]$sdrep$jointPrecision) # names(mle) == rownames(vcov)
samples <- MASS::mvrnorm(weights[i], mu = mle, Sigma = vcov)
# - Get quantities
quantities <- apply(samples, 1, function(x) Rceattle[[i]]$obj$report(x)[c("biomass", "biomassSSB", "R")]) # Only want uncertainty in SSB, B, and R
# Extract number of species of each model
nspp <- sapply(Rceattle, function(x) x$data_list$nspp)
nspp <- unique(nspp)
if(length(nspp) > 1){stop("Number of species does not match across models")}
# Extract timespan of each model
years <- sapply(Rceattle, function(x) x$data_list$styr:x$data_list$projyr)
endyrs <- sapply(Rceattle, function(x) x$data_list$endyr)
styrs <- sapply(Rceattle, function(x) x$data_list$styr)
projyrs <- sapply(Rceattle, function(x) x$data_list$projyr)
nyrs <- sapply(years, length)
min_projyr <- min(projyrs, na.rm = TRUE) # Find coverage across all models
min_hindyr <- min(endyrs, na.rm = TRUE) # Find coverage across all models
max_styr <- max(styrs, na.rm = TRUE)
# Initialize model average object
mod_avg <- Rceattle[[which(nyrs == min(nyrs))[1]]] # Copy a model of the smallest length to fill in
mod_avg_rel_proj_yrs <- (max_styr - mod_avg$data_list$styr + 1) : (min_projyr - mod_avg$data_list$styr + 1) # Find years of overlap
mod_avg_rel_hind_yrs <- (max_styr - mod_avg$data_list$styr + 1) : (min_hindyr - mod_avg$data_list$styr + 1) # Find years of overlap
mod_avg$estimated_params <- mod_avg$initial_params <- mod_avg$opt <- mod_avg$run_time <- mod_avg$obj <- mod_avg$map <- mod_avg$bounds <- NULL
# Assuming asymptotic multivariate normal
# - Must have estimated joint precision matrix
joint_est <- sapply(Rceattle, function(x) is.null(x$sdrep$jointPrecision))
if(sum(joint_est) > 0){
stop(paste("Model(s):", which(joint_est > 0)," do not have joint precision matrices: re-estimate with getJointPrecision = TRUE"))
}
# List to save samples of SSB, B, and R
recruitment <-
array(NA, dim = c(nspp, length(mod_avg_rel_proj_yrs),  sum(weights)))
biomassSSB <-
array(NA, dim = c(nspp, length(mod_avg_rel_proj_yrs),  sum(weights)))
biomass <-
array(NA, dim = c(nspp, length(mod_avg_rel_proj_yrs),  sum(weights)))
# Loop across models
for(i in 1:length(Rceattle)){
# - Sample parameters from asymptotic normal distribution
mle <- Rceattle[[i]]$obj$env$last.par.best # Includes fixed and random
vcov <- solve(Rceattle[[i]]$sdrep$jointPrecision) # names(mle) == rownames(vcov)
samples <- MASS::mvrnorm(weights[i], mu = mle, Sigma = vcov)
# - Get quantities
quantities <- apply(samples, 1, function(x) Rceattle[[i]]$obj$report(x)[c("biomass", "biomassSSB", "R")]) # Only want uncertainty in SSB, B, and R
# - Subset years of interest and assign to objects
sub_rel_proj_yrs <- (max_styr - Rceattle[[i]]$data_list$styr + 1) : (min_projyr - Rceattle[[i]]$data_list$styr + 1) # Find years of overlap
# Extract R, B, and SSB and assign to objects
recruitment[1:nspp, 1:length(mod_avg_rel_proj_yrs), nrows[which(rowid == i)]] <- unlist(lapply(quantities, function(x) x$R[, sub_rel_proj_yrs]))
biomassSSB[1:nspp, 1:length(mod_avg_rel_proj_yrs), nrows[which(rowid == i)]] <- unlist(lapply(quantities, function(x) x$biomassSSB[, sub_rel_proj_yrs]))
biomass[1:nspp, 1:length(mod_avg_rel_proj_yrs), nrows[which(rowid == i)]] <- unlist(lapply(quantities, function(x) x$biomass[, sub_rel_proj_yrs]))
}
# - Calculate SD
rec_rows <- which(names(mod_avg$sdrep$value) == "R")
mod_avg$sdrep$sd[rec_rows] <- sqrt(apply(recruitment, 3, var))
biomass_rows <- which(names(mod_avg$sdrep$value) == "biomass")
mod_avg$sdrep$sd[biomass_rows] <- sqrt(apply(biomass, 3, var))
ssb_rows <- which(names(mod_avg$sdrep$value) == "biomassSSB")
mod_avg$sdrep$sd[ssb_rows] <- sqrt(apply(biomassSSB, 3, var))
# - Save samples
mod_avg$asymptotic_samples <- list(recruitment = recruitment, biomass = biomass, biomassSSB = biomassSSB)
nrows <- 1:sum(weights)
rowid <- rep(1:length(weights), weights)
nrows
rowid
# Loop across models
for(i in 1:length(Rceattle)){
# - Sample parameters from asymptotic normal distribution
mle <- Rceattle[[i]]$obj$env$last.par.best # Includes fixed and random
vcov <- solve(Rceattle[[i]]$sdrep$jointPrecision) # names(mle) == rownames(vcov)
samples <- MASS::mvrnorm(weights[i], mu = mle, Sigma = vcov)
# - Get quantities
quantities <- apply(samples, 1, function(x) Rceattle[[i]]$obj$report(x)[c("biomass", "biomassSSB", "R")]) # Only want uncertainty in SSB, B, and R
# - Subset years of interest and assign to objects
sub_rel_proj_yrs <- (max_styr - Rceattle[[i]]$data_list$styr + 1) : (min_projyr - Rceattle[[i]]$data_list$styr + 1) # Find years of overlap
# Extract R, B, and SSB and assign to objects
recruitment[1:nspp, 1:length(mod_avg_rel_proj_yrs), nrows[which(rowid == i)]] <- unlist(lapply(quantities, function(x) x$R[, sub_rel_proj_yrs]))
biomassSSB[1:nspp, 1:length(mod_avg_rel_proj_yrs), nrows[which(rowid == i)]] <- unlist(lapply(quantities, function(x) x$biomassSSB[, sub_rel_proj_yrs]))
biomass[1:nspp, 1:length(mod_avg_rel_proj_yrs), nrows[which(rowid == i)]] <- unlist(lapply(quantities, function(x) x$biomass[, sub_rel_proj_yrs]))
}
# - Calculate SD
rec_rows <- which(names(mod_avg$sdrep$value) == "R")
mod_avg$sdrep$sd[rec_rows] <- sqrt(apply(recruitment, 3, var))
biomass_rows <- which(names(mod_avg$sdrep$value) == "biomass")
sqrt(apply(recruitment, 3, var))
dim(recruitment)
sapply(recruitment, 3, var)
dim(apply(recruitment, 3, var))
apply(recruitment, c(1,2), var)
dim(apply(recruitment, c(1,2), var))
# - Calculate SD
rec_rows <- which(names(mod_avg$sdrep$value) == "R")
mod_avg$sdrep$sd[rec_rows] <- sqrt(apply(recruitment, c(1,2), var))
biomass_rows <- which(names(mod_avg$sdrep$value) == "biomass")
mod_avg$sdrep$sd[biomass_rows] <- sqrt(apply(biomass, c(1,2), var))
ssb_rows <- which(names(mod_avg$sdrep$value) == "biomassSSB")
mod_avg$sdrep$sd[ssb_rows] <- sqrt(apply(biomassSSB, c(1,2), var))
ssb_rows
mod_avg$sdrep$value[ssb_rows]
apply(biomassSSB, c(1,2), mean)
c(apply(biomassSSB, c(1,2), mean))
mod_avg$sdrep$value[ssb_rows]
c(mod_avg$sdrep$value[ssb_rows])
c(apply(biomassSSB, c(1,2), mean))
plot(c(mod_avg$sdrep$value[ssb_rows]), c(apply(biomassSSB, c(1,2), mean)))
abline(1,1)
# - Calculate SD
rec_rows <- which(names(mod_avg$sdrep$value) == "R")
mod_avg$sdrep$sd[rec_rows] <- sqrt(apply(recruitment, c(1,2), var))
biomass_rows <- which(names(mod_avg$sdrep$value) == "biomass")
mod_avg$sdrep$sd[biomass_rows] <- sqrt(apply(biomass, c(1,2), var))
ssb_rows <- which(names(mod_avg$sdrep$value) == "biomassSSB")
mod_avg$sdrep$sd[ssb_rows] <- sqrt(apply(biomassSSB, c(1,2), var))
# - Save samples
mod_avg$asymptotic_samples <- list(recruitment = recruitment, biomass = biomass, biomassSSB = biomassSSB)
load("~/GitHub/RceattleRuns/GOA/Model runs/GOA_18.5.1/Models/18_5_1_Niter3_2021-06-14.RData")
Rceattle <- mod_list_all
# --------------------------------------------------------------------------------------------
# Average derived quantities of models
# --------------------------------------------------------------------------------------------
# Convert single one into a list
if(class(Rceattle) == "Rceattle"){
stop("Only one model provided")
}
# Extract number of species of each model
nspp <- sapply(Rceattle, function(x) x$data_list$nspp)
nspp <- unique(nspp)
if(length(nspp) > 1){stop("Number of species does not match across models")}
# Extract timespan of each model
years <- sapply(Rceattle, function(x) x$data_list$styr:x$data_list$projyr)
endyrs <- sapply(Rceattle, function(x) x$data_list$endyr)
styrs <- sapply(Rceattle, function(x) x$data_list$styr)
projyrs <- sapply(Rceattle, function(x) x$data_list$projyr)
nyrs <- sapply(years, length)
min_projyr <- min(projyrs, na.rm = TRUE) # Find coverage across all models
min_hindyr <- min(endyrs, na.rm = TRUE) # Find coverage across all models
max_styr <- max(styrs, na.rm = TRUE)
# Initialize model average object
mod_avg <- Rceattle[[which(nyrs == min(nyrs))[1]]] # Copy a model of the smallest length to fill in
mod_avg_rel_proj_yrs <- (max_styr - mod_avg$data_list$styr + 1) : (min_projyr - mod_avg$data_list$styr + 1) # Find years of overlap
mod_avg_rel_hind_yrs <- (max_styr - mod_avg$data_list$styr + 1) : (min_hindyr - mod_avg$data_list$styr + 1) # Find years of overlap
mod_avg$estimated_params <- mod_avg$initial_params <- mod_avg$opt <- mod_avg$run_time <- mod_avg$obj <- mod_avg$map <- mod_avg$bounds <- NULL
if(!uncertainty){mod_avg$sdrep <- NULL}
# -- Set all quantities to zero
for(i in 1:length(mod_avg$quantities)){
mod_avg$quantities[[i]] <- replace(mod_avg$quantities[[i]], values = rep(0, length(mod_avg$quantities[[i]])))
}
# Assuming asymptotic multivariate normal
# - Must have estimated joint precision matrix
joint_est <- sapply(Rceattle, function(x) is.null(x$sdrep$jointPrecision))
joint_est
mod_list[[1]]$sdrep$par.random
mod_list_all[[1]]$sdrep$par.random
# Assuming asymptotic multivariate normal
# - Must have estimated joint precision matrix
length_ran <- sapply(Rceattle, function(x) is.null(x$sdrep$par.random)) # All parameters random effects
length_ran
# Assuming asymptotic multivariate normal
# - Must have estimated joint precision matrix
length_ran <- sapply(Rceattle, function(x) !is.null(x$sdrep$par.random)) # All parameters random effects
length_ran
length_ran
mod_list_all[[1]]$sdrep$cov
mod_list_all[[1]]$sdrep$cov.fixed
mle <- Rceattle[[i]]$obj$env$last.par.best # Includes fixed and random
vcov <- solve(Rceattle[[i]]$sdrep$cov.fixed) # names(mle) == rownames(vcov)
i
i =
1
mle <- Rceattle[[i]]$obj$env$last.par.best # Includes fixed and random
vcov <- solve(Rceattle[[i]]$sdrep$cov.fixed) # names(mle) == rownames(vcov)
names(mle) == rownames(vcov)
devtools::document()
