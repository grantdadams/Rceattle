suitMode = om_use$data_list$suitMode,
initMode = om_use$data_list$initMode,
suit_meanyr = om$data_list$suit_meanyr, # This stays the same as original OM
HCR = build_hcr(HCR = om_use$data_list$HCR,
DynamicHCR = om_use$data_list$DynamicHCR,
FsprTarget = om_use$data_list$FsprTarget,
FsprLimit = om_use$data_list$FsprLimit,
Ptarget = om_use$data_list$Ptarget,
Plimit = om_use$data_list$Plimit,
Alpha = om_use$data_list$Alpha,
Pstar = om_use$data_list$Pstar,
Sigma = om_use$data_list$Sigma,
Fmult = om_use$data_list$Fmult
),
recFun = build_srr(srr_fun = om_use$data_list$srr_fun,
srr_pred_fun = om_use$data_list$srr_pred_fun ,
proj_mean_rec = om_use$data_list$proj_mean_rec, # This will update anyway to False as devs are added
srr_meanyr = om$data_list$srr_meanyr, # This stays the same as original OM
srr_est_mode  = om_use$data_list$srr_est_mode ,
srr_prior_mean = om_use$data_list$srr_prior_mean,
srr_prior_sd = om_use$data_list$srr_prior_sd,
Bmsy_lim = om_use$data_list$Bmsy_lim,
srr_env_indices = om_use$data_list$srr_env_indices),
M1Fun = build_M1(M1_model= om_use$data_list$M1_model,
updateM1 = FALSE,
M1_use_prior = om_use$data_list$M1_use_prior,
M2_use_prior = om_use$data_list$M2_use_prior,
M1_prior_mean = om_use$data_list$M1_prior_mean,
M1_prior_sd = om_use$data_list$M1_prior_sd), # Dont update M1 from data, fix at previous parameters
loopnum = loopnum,
phase = NULL,
getsd = FALSE,
verbose = 0)
},
timeout = 60*timeout)
},
error = function(e){
return(TRUE)
},
TimeoutException = function(e){
return(TRUE)
})
if(kill_sim){
break()
}
return(FALSE)
om_use <- fit_mod(
data_list = om_use$data_list,
inits = om_use$estimated_params,
map =  om_use$map,
bounds = NULL,
file = NULL,
estimateMode = estimate_mode_use,
random_rec = om_use$data_list$random_rec,
niter = om_use$data_list$niter,
msmMode = om_use$data_list$msmMode,
avgnMode = om_use$data_list$avgnMode,
suitMode = om_use$data_list$suitMode,
initMode = om_use$data_list$initMode,
suit_meanyr = om$data_list$suit_meanyr, # This stays the same as original OM
HCR = build_hcr(HCR = om_use$data_list$HCR,
DynamicHCR = om_use$data_list$DynamicHCR,
FsprTarget = om_use$data_list$FsprTarget,
FsprLimit = om_use$data_list$FsprLimit,
Ptarget = om_use$data_list$Ptarget,
Plimit = om_use$data_list$Plimit,
Alpha = om_use$data_list$Alpha,
Pstar = om_use$data_list$Pstar,
Sigma = om_use$data_list$Sigma,
Fmult = om_use$data_list$Fmult
),
recFun = build_srr(srr_fun = om_use$data_list$srr_fun,
srr_pred_fun = om_use$data_list$srr_pred_fun ,
proj_mean_rec = om_use$data_list$proj_mean_rec, # This will update anyway to False as devs are added
srr_meanyr = om$data_list$srr_meanyr, # This stays the same as original OM
srr_est_mode  = om_use$data_list$srr_est_mode ,
srr_prior_mean = om_use$data_list$srr_prior_mean,
srr_prior_sd = om_use$data_list$srr_prior_sd,
Bmsy_lim = om_use$data_list$Bmsy_lim,
srr_env_indices = om_use$data_list$srr_env_indices),
M1Fun = build_M1(M1_model= om_use$data_list$M1_model,
updateM1 = FALSE,
M1_use_prior = om_use$data_list$M1_use_prior,
M2_use_prior = om_use$data_list$M2_use_prior,
M1_prior_mean = om_use$data_list$M1_prior_mean,
M1_prior_sd = om_use$data_list$M1_prior_sd), # Dont update M1 from data, fix at previous parameters
loopnum = loopnum,
phase = NULL,
getsd = FALSE,
verbose = 0)
# * Fit OM with new catch data ----
kill_sim <- tryCatch({
R.utils::withTimeout({
om_use <- fit_mod(
data_list = om_use$data_list,
inits = om_use$estimated_params,
map =  om_use$map,
bounds = NULL,
file = NULL,
estimateMode = estimate_mode_use,
random_rec = om_use$data_list$random_rec,
niter = om_use$data_list$niter,
msmMode = om_use$data_list$msmMode,
avgnMode = om_use$data_list$avgnMode,
suitMode = om_use$data_list$suitMode,
initMode = om_use$data_list$initMode,
suit_meanyr = om$data_list$suit_meanyr, # This stays the same as original OM
HCR = build_hcr(HCR = om_use$data_list$HCR,
DynamicHCR = om_use$data_list$DynamicHCR,
FsprTarget = om_use$data_list$FsprTarget,
FsprLimit = om_use$data_list$FsprLimit,
Ptarget = om_use$data_list$Ptarget,
Plimit = om_use$data_list$Plimit,
Alpha = om_use$data_list$Alpha,
Pstar = om_use$data_list$Pstar,
Sigma = om_use$data_list$Sigma,
Fmult = om_use$data_list$Fmult
),
recFun = build_srr(srr_fun = om_use$data_list$srr_fun,
srr_pred_fun = om_use$data_list$srr_pred_fun ,
proj_mean_rec = om_use$data_list$proj_mean_rec, # This will update anyway to False as devs are added
srr_meanyr = om$data_list$srr_meanyr, # This stays the same as original OM
srr_est_mode  = om_use$data_list$srr_est_mode ,
srr_prior_mean = om_use$data_list$srr_prior_mean,
srr_prior_sd = om_use$data_list$srr_prior_sd,
Bmsy_lim = om_use$data_list$Bmsy_lim,
srr_env_indices = om_use$data_list$srr_env_indices),
M1Fun = build_M1(M1_model= om_use$data_list$M1_model,
updateM1 = FALSE,
M1_use_prior = om_use$data_list$M1_use_prior,
M2_use_prior = om_use$data_list$M2_use_prior,
M1_prior_mean = om_use$data_list$M1_prior_mean,
M1_prior_sd = om_use$data_list$M1_prior_sd), # Dont update M1 from data, fix at previous parameters
loopnum = loopnum,
phase = NULL,
getsd = FALSE,
verbose = 0)
return(FALSE)
},
timeout = 60*timeout)
},
error = function(e){
return(TRUE)
},
TimeoutException = function(e){
return(TRUE)
})
kill_sim
R.utils::withTimeout({
om_use <- fit_mod(
data_list = om_use$data_list,
inits = om_use$estimated_params,
map =  om_use$map,
bounds = NULL,
file = NULL,
estimateMode = estimate_mode_use,
random_rec = om_use$data_list$random_rec,
niter = om_use$data_list$niter,
msmMode = om_use$data_list$msmMode,
avgnMode = om_use$data_list$avgnMode,
suitMode = om_use$data_list$suitMode,
initMode = om_use$data_list$initMode,
suit_meanyr = om$data_list$suit_meanyr, # This stays the same as original OM
HCR = build_hcr(HCR = om_use$data_list$HCR,
DynamicHCR = om_use$data_list$DynamicHCR,
FsprTarget = om_use$data_list$FsprTarget,
FsprLimit = om_use$data_list$FsprLimit,
Ptarget = om_use$data_list$Ptarget,
Plimit = om_use$data_list$Plimit,
Alpha = om_use$data_list$Alpha,
Pstar = om_use$data_list$Pstar,
Sigma = om_use$data_list$Sigma,
Fmult = om_use$data_list$Fmult
),
recFun = build_srr(srr_fun = om_use$data_list$srr_fun,
srr_pred_fun = om_use$data_list$srr_pred_fun ,
proj_mean_rec = om_use$data_list$proj_mean_rec, # This will update anyway to False as devs are added
srr_meanyr = om$data_list$srr_meanyr, # This stays the same as original OM
srr_est_mode  = om_use$data_list$srr_est_mode ,
srr_prior_mean = om_use$data_list$srr_prior_mean,
srr_prior_sd = om_use$data_list$srr_prior_sd,
Bmsy_lim = om_use$data_list$Bmsy_lim,
srr_env_indices = om_use$data_list$srr_env_indices),
M1Fun = build_M1(M1_model= om_use$data_list$M1_model,
updateM1 = FALSE,
M1_use_prior = om_use$data_list$M1_use_prior,
M2_use_prior = om_use$data_list$M2_use_prior,
M1_prior_mean = om_use$data_list$M1_prior_mean,
M1_prior_sd = om_use$data_list$M1_prior_sd), # Dont update M1 from data, fix at previous parameters
loopnum = loopnum,
phase = NULL,
getsd = FALSE,
verbose = 0)
return(FALSE)
}
)
timeout = 10
# * Fit OM with new catch data ----
kill_sim <- tryCatch({
R.utils::withTimeout({
om_use <- fit_mod(
data_list = om_use$data_list,
inits = om_use$estimated_params,
map =  om_use$map,
bounds = NULL,
file = NULL,
estimateMode = estimate_mode_use,
random_rec = om_use$data_list$random_rec,
niter = om_use$data_list$niter,
msmMode = om_use$data_list$msmMode,
avgnMode = om_use$data_list$avgnMode,
suitMode = om_use$data_list$suitMode,
initMode = om_use$data_list$initMode,
suit_meanyr = om$data_list$suit_meanyr, # This stays the same as original OM
HCR = build_hcr(HCR = om_use$data_list$HCR,
DynamicHCR = om_use$data_list$DynamicHCR,
FsprTarget = om_use$data_list$FsprTarget,
FsprLimit = om_use$data_list$FsprLimit,
Ptarget = om_use$data_list$Ptarget,
Plimit = om_use$data_list$Plimit,
Alpha = om_use$data_list$Alpha,
Pstar = om_use$data_list$Pstar,
Sigma = om_use$data_list$Sigma,
Fmult = om_use$data_list$Fmult
),
recFun = build_srr(srr_fun = om_use$data_list$srr_fun,
srr_pred_fun = om_use$data_list$srr_pred_fun ,
proj_mean_rec = om_use$data_list$proj_mean_rec, # This will update anyway to False as devs are added
srr_meanyr = om$data_list$srr_meanyr, # This stays the same as original OM
srr_est_mode  = om_use$data_list$srr_est_mode ,
srr_prior_mean = om_use$data_list$srr_prior_mean,
srr_prior_sd = om_use$data_list$srr_prior_sd,
Bmsy_lim = om_use$data_list$Bmsy_lim,
srr_env_indices = om_use$data_list$srr_env_indices),
M1Fun = build_M1(M1_model= om_use$data_list$M1_model,
updateM1 = FALSE,
M1_use_prior = om_use$data_list$M1_use_prior,
M2_use_prior = om_use$data_list$M2_use_prior,
M1_prior_mean = om_use$data_list$M1_prior_mean,
M1_prior_sd = om_use$data_list$M1_prior_sd), # Dont update M1 from data, fix at previous parameters
loopnum = loopnum,
phase = NULL,
getsd = FALSE,
verbose = 0)
return(FALSE)
},
timeout = 60*timeout)
},
error = function(e){
return(TRUE)
},
TimeoutException = function(e){
return(TRUE)
})
kill_sim
if(kill_sim){
break()
}
# -- Set estimate mode back to original
om_use$data_list$estimateMode <- estimate_mode_base
# - Get realized catch data from OM
new_catch_data <- om_use$data_list$fsh_biom
dat_fill_ind <- which(new_catch_data$Year %in% new_years)
new_catch_data$Catch[dat_fill_ind] <- om_use$quantities$fsh_bio_hat[dat_fill_ind] # Catch from OM
# - Update catch data in OM and EM
om_use$data_list$fsh_biom <- new_catch_data
em_use$data_list$fsh_biom <- new_catch_data
# ------------------------------------------------------------
# 4. REFIT ESTIMATION MODEL AND HCR ----
# ------------------------------------------------------------
# - Simulate new survey and comp data
sim_dat <- sim_mod(om_use, simulate = simulate_data)
years_include <- sample_yrs[which(sample_yrs$Year > em_use$data_list$endyr & sample_yrs$Year <= assess_yrs[k]),]
# -- Add newly simulated survey data to EM
new_srv_biom <- sim_dat$srv_biom[which(abs(sim_dat$srv_biom$Year) %in% years_include$Year & sim_dat$srv_biom$Fleet_code %in% years_include$Fleet_code),]
new_srv_biom$Year <- -new_srv_biom$Year
em_use$data_list$srv_biom <- rbind(em_use$data_list$srv_biom, new_srv_biom)
em_use$data_list$srv_biom <- em_use$data_list$srv_biom[
with(em_use$data_list$srv_biom, order(Fleet_code, abs(Year))),]
# -- Add newly simulated comp data to EM
new_comp_data <- sim_dat$comp_data[which(abs(sim_dat$comp_data$Year) %in% years_include$Year & sim_dat$comp_data$Fleet_code %in% years_include$Fleet_code),]
new_comp_data$Year <- -new_comp_data$Year
new_comp_data$Sample_size <- new_comp_data$Sample_size * as.numeric(rowSums(new_comp_data[,9:ncol(new_comp_data)]) > 0) # Set sample size to 0 if catch is 0
new_comp_data[,9:ncol(new_comp_data)] <- new_comp_data[,9:ncol(new_comp_data)] + 1 * as.numeric(new_comp_data$Sample_size == 0) # Set all values to 1 if catch is 0
em_use$data_list$comp_data <- rbind(em_use$data_list$comp_data, new_comp_data)
em_use$data_list$comp_data <- em_use$data_list$comp_data[
with(em_use$data_list$comp_data, order(Fleet_code, abs(Year))),]
# Update end year and re-estimate
em_use$data_list$endyr <- assess_yrs[k]
# Update parameters
# -- F_dev
em_use$estimated_params$F_dev <- cbind(em_use$estimated_params$F_dev, matrix(0, nrow= nrow(em_use$estimated_params$F_dev), ncol = length(new_years)))
# -- Time-varying survey catachbilitiy - Assume last year - filled by columns
em_use$estimated_params$ln_srv_q_dev <- cbind(em_use$estimated_params$ln_srv_q_dev, matrix(em_use$estimated_params$ln_srv_q_dev[,ncol(em_use$estimated_params$ln_srv_q_dev)], nrow= nrow(em_use$estimated_params$ln_srv_q_dev), ncol = length(new_years)))
# -- Time-varing selectivity - Assume last year - filled by columns
ln_sel_slp_dev = array(0, dim = c(2, nflts, 2, nyrs_hind + length(new_years)))  # selectivity deviations paramaters for logistic
sel_inf_dev = array(0, dim = c(2, nflts, 2, nyrs_hind + length(new_years)))  # selectivity deviations paramaters for logistic
ln_sel_slp_dev[,,,1:nyrs_hind] <- em_use$estimated_params$ln_sel_slp_dev
sel_inf_dev[,,,1:nyrs_hind] <- em_use$estimated_params$sel_inf_dev
# - Initialize new years with last year
ln_sel_slp_dev[,,,(nyrs_hind + 1):(nyrs_hind + length(new_years))] <- ln_sel_slp_dev[,,,nyrs_hind]
sel_inf_dev[,,,(nyrs_hind + 1):(nyrs_hind + length(new_years))] <- sel_inf_dev[,,,nyrs_hind]
em_use$estimated_params$ln_sel_slp_dev <- ln_sel_slp_dev
em_use$estimated_params$sel_inf_dev <- sel_inf_dev
# Restimate
em_use <- tryCatch({
R.utils::withTimeout({
fit_mod(
data_list = em_use$data_list,
inits = em_use$estimated_params,
map =  NULL,
bounds = NULL,
file = NULL,
estimateMode = ifelse(em_use$data_list$estimateMode < 3, 0, em_use$data_list$estimateMode), # Run hindcast and projection, otherwise debug
HCR = build_hcr(HCR = em_use$data_list$HCR, # Tier3 HCR
DynamicHCR = em_use$data_list$DynamicHCR,
FsprTarget = em_use$data_list$FsprTarget,
FsprLimit = em_use$data_list$FsprLimit,
Ptarget = em_use$data_list$Ptarget,
Plimit = em_use$data_list$Plimit,
Alpha = em_use$data_list$Alpha,
Pstar = em_use$data_list$Pstar,
Sigma = em_use$data_list$Sigma,
Fmult = em_use$data_list$Fmult
),
recFun = build_srr(srr_fun = em_use$data_list$srr_fun,
srr_pred_fun = em_use$data_list$srr_pred_fun,
proj_mean_rec = em_use$data_list$proj_mean_rec,
srr_meanyr = em_use$data_list$endyr, # Update end year
srr_est_mode  = em_use$data_list$srr_est_mode ,
srr_prior_mean = em_use$data_list$srr_prior_mean,
srr_prior_sd = em_use$data_list$srr_prior_sd,
Bmsy_lim = em_use$data_list$Bmsy_lim,
srr_env_indices = em_use$data_list$srr_env_indices),
M1Fun =     build_M1(M1_model= em_use$data_list$M1_model,
updateM1 = FALSE,
M1_use_prior = em_use$data_list$M1_use_prior,
M2_use_prior = em_use$data_list$M2_use_prior,
M1_prior_mean = em_use$data_list$M1_prior_mean,
M1_prior_sd = em_use$data_list$M1_prior_sd),
random_rec = em_use$data_list$random_rec,
niter = em_use$data_list$niter,
msmMode = em_use$data_list$msmMode,
avgnMode = em_use$data_list$avgnMode,
suitMode = em_use$data_list$suitMode,
suit_meanyr = em_use$data_list$suit_meanyr,
initMode = em_use$data_list$initMode,
phase = NULL,
loopnum = loopnum,
getsd = FALSE,
verbose = 0)
},
timeout = 60*timeout)
},
error = function(ex) {
return(NULL)
},
TimeoutException = function(ex) {
return(NULL)
})
if(is.null(em_use)){
kill_sim <- TRUE
break()
}
# - Remove unneeded bits for memory reasons
em_use$initial_params <- NULL
em_use$bounds <- NULL
em_use$map <- NULL
em_use$obj <- NULL
em_use$opt <- NULL
em_use$sdrep <- NULL
em_use$quantities[names(em_use$quantities) %!in% c("fsh_bio_hat",
"fsh_log_sd_hat",
"srv_bio_hat",
"srv_log_sd_hat",
"depletion",
"depletionSSB",
"biomass",
"biomassSSB",
"BO",
"SB0",
"SBF",
"F_spp",
"R",
"M1",
"M",
"mean_rec",
"DynamicB0",
"DynamicSB0",
"DynamicSBF",
"SPR0",
"SPRlimit",
"SPRtarget",
"Ftarget",
"Flimit")] <- NULL
sim_list$EM[[k+1]] <- em_use
#sim_list$OM[[k+1]] <- om_use
message(paste0("Sim ",sim, " - EM Year ", assess_yrs[k], " COMPLETE"))
source("~/GitHub/Rceattle/R/11a-mse_run_parallel.R")
# - SS-OM: SS-EM No F
mse3 <- mse_run_parallel(om = ss_run, em = ss_run_Tier3, nsim = 1, assessment_period = 1, sampling_period = 1, simulate_data = TRUE, sample_rec = TRUE, cap = NULL)
plot_biomass(mse3[[1]]$OM)
# - SS-OM: SS-EM No F
mse3 <- mse_run_parallel(om = ss_run, em = ss_run, nsim = 1, assessment_period = 1, sampling_period = 1, simulate_data = TRUE, sample_rec = TRUE, cap = NULL)
plot_biomass(mse3[[1]]$OM)
source("~/GitHub/Rceattle/R/11a-mse_run_parallel.R")
# - SS-OM: SS-EM No F
mse3 <- mse_run_parallel(om = ss_run, em = ss_run, nsim = 1, assessment_period = 1, sampling_period = 1, simulate_data = TRUE, sample_rec = TRUE, cap = NULL)
source("~/GitHub/Rceattle/R/11a-mse_run_parallel.R")
# - SS-OM: SS-EM No F
mse3 <- mse_run_parallel(om = ss_run, em = ss_run, nsim = 1, assessment_period = 1, sampling_period = 1, simulate_data = TRUE, sample_rec = TRUE, cap = NULL)
Rceattle <- ss_run
# * Years for F = 0 ----
# - don't want hindcast or it will bias suitability in Multi-species models
proj_years <- Rceattle$data_list$suit_meanyr:Rceattle$data_list$projyr - Rceattle$data_list$styr + 1
# * Set F to 0 ----
Rceattle$estimated_params$F_dev[,proj_years] <- replace(Rceattle$estimated_params$F_dev[,proj_years], values = -999)
proj_years
Rceattle$estimated_params$F_dev[,proj_years]
ncol(Rceattle$estimated_params$F_dev)
Rceattle$data_list$suit_meanyr:Rceattle$data_list$projyr
# * Years for F = 0 ----
# - don't want hindcast or it will bias suitability in Multi-species models
proj_years <- (Rceattle$data_list$suit_meanyr+1):Rceattle$data_list$projyr - Rceattle$data_list$styr + 1
proj_years
fdevs_proj <- ncol(Rceattle$estimated_params$F_dev)
fdevs_proj
fdevs_proj <- 1:ncol(Rceattle$estimated_params$F_dev)
# * Years for F = 0 ----
# - don't want hindcast or it will bias suitability in Multi-species models
proj_years <- (Rceattle$data_list$suit_meanyr+1):Rceattle$data_list$projyr - Rceattle$data_list$styr + 1
fdevs_cols <- 1:ncol(Rceattle$estimated_params$F_dev)
fdevs_change <- fdevs_cols %in% proj_years
fdevs_change
fdevs_change <- which(fdevs_cols %in% proj_years)
fdevs_change
# * Set F to 0 ----
Rceattle$estimated_params$F_dev[,fdevs_change] <- replace(Rceattle$estimated_params$F_dev[,fdevs_change], values = -999)
Rceattle$estimated_params$F_dev[,fdevs_change]
replace(Rceattle$estimated_params$F_dev[,fdevs_change], values = -999)
Rceattle$estimated_params$F_dev[,fdevs_change]
fdevs_change
source("~/GitHub/Rceattle/R/11c-project-no-F.R")
source("~/GitHub/Rceattle/R/11a-mse_run_parallel.R")
# - SS-OM: SS-EM No F
mse3 <- mse_run_parallel(om = ss_run, em = ss_run, nsim = 1, assessment_period = 1, sampling_period = 1, simulate_data = TRUE, sample_rec = TRUE, cap = NULL)
source("~/GitHub/Rceattle/R/11a-mse_run_parallel.R")
# - SS-OM: SS-EM No F
mse3 <- mse_run_parallel(om = ss_run, em = ss_run, nsim = 1, assessment_period = 1, sampling_period = 1, simulate_data = TRUE, sample_rec = TRUE, cap = NULL)
plot_biomass(mse3[[1]]$OM_no_F)
library(TMB)
?compile
devtools::document()
library(Rceattle)
# Grant Adams, Kirstin Holsman, Andre Punt - April 2019
# Code to run Bering Sea CEATTLE model in TMB
# Citation:
# Holsman, K. K., Ianelli, J., Aydin, K., Punt, A. E., and Moffitt, E. A. 2015. A comparison of fisheries biological reference points estimated from temperature-specific multi-species and single-species climate-enhanced stock assessment models. Deep-Sea Research Part II: Topical Studies in Oceanography, 134: 360–378.
library(Rceattle)
################################################
# Data
################################################
# Example
# To run the 2017 single species assessment for the Bering Sea, a data file must first be loaded:
data("BS2017SS") # Single-species data. ?BS2017SS for more information on the data
data("BS2017MS") # Multi-species data. Note: the only difference is the residual mortality (M1_base) is lower
# Write data to excel
Rceattle::write_data(data_list = BS2017SS, file = "BS2017SS.xlsx")
# Change the data how you want in excel
# Read the data back in
mydata <- Rceattle::read_data( file = "BS2017SS.xlsx")
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
mydata$fleet_control$proj_F_prop <- c(rep(1,3), rep(0,4))
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = "default",
verbose = 1)
plot_biomass(ss_run, add_ci = TRUE)
# Code to run Gulf of Alaska CEATTLE model in TMB
# Citation:
# Adams, G. D., Holsman, K. K., Barbeaux, S. J., Dorn, M. W., Ianelli, J. N., Spies, I., ... & Punt, A. E. (2022). An ensemble approach to understand predation mortality for groundfish in the Gulf of Alaska. Fisheries Research, 251, 106303.
library(Rceattle)
################################################
# Data
################################################
# Example
# To run the 2018 single species assessment for the Gulf of Alaska, a data file must first be loaded:
data("GOA2018SS") # Single-species data. ?BS2017SS for more information on the data
################################################
# Estimation
################################################
# - Single-species
# Then the model can be fit by setting `msmMode = 0` using the `Rceattle` function:
GOA2018SS$fleet_control$proj_F_prop <- rep(1, nrow(GOA2018SS$fleet_control))
ss_run <- Rceattle::fit_mod(data_list = GOA2018SS,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = "default",
verbose = 1)
plot_biomass(ss_run, add_ci = TRUE)
library(Rceattle)
