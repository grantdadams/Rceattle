#   proj_F_prop = 14, # Fixed fleet-specific proportion of Flimit and Ftarget apportioned within each species
#   F_dev = 7, # Annual fleet specific fishing mortality deviates
#   ln_srv_q = 10, # Survey catchability
#   ln_srv_q_dev = 11, # Annual survey catchability deviates (if time-varying)
#   ln_sigma_srv_q = 15, # Prior SD for survey catchability deviates
#   ln_sigma_time_varying_srv_q = 15, # SD for annual survey catchability deviates (if time-varying)
#   sel_coff = 8, # Non-parametric selectivity coefficients
#   sel_coff_dev = 11, # Annual deviates for non-parametric selectivity coefficients
#   ln_sel_slp = 9, # Slope parameters for logistic forms of selectivity
#   sel_inf = 9, # Asymptote parameters for logistic forms of selectivity
#   ln_sel_slp_dev = 11, # Annual deviates for slope parameters for logistic forms of selectivity (if time-varying)
#   sel_inf_dev = 11, # Annual deviates for asymptote parameters for logistic forms of selectivity (if time-varying)
#   ln_sigma_sel = 12, # SD for annual selectivity deviates (if time-varying)
#   sel_curve_pen = 13, # Penalty for non-parametric selectivity
#   ln_sigma_srv_index = 14, # Log SD for survey lognormal index likelihood (usually input)
#   ln_sigma_fsh_catch = 14, # Log SD for lognormal catch likelihood (usually input)
#   comp_weights = 15, # Weights for multinomial comp likelihood
#   logH_1 = 15,  # Functional form parameter (not used in MSVPA functional form)
#   logH_1a = 15, # Functional form parameter (not used in MSVPA functional form)
#   logH_1b = 15, # Functional form parameter (not used in MSVPA functional form)
#   logH_2 = 15, # Functional form parameter (not used in MSVPA functional form)
#   logH_3 = 15, # Functional form parameter (not used in MSVPA functional form)
#   H_4 = 15, # Functional form parameter (not used in MSVPA functional form)
#   log_gam_a = 15, # Suitability parameter (not used in MSVPA style)
#   log_gam_b = 15, # Suitability parameter (not used in MSVPA style)
#   log_phi = 15 # Suitability parameter (not used in MSVPA style)
# )
}
}
if(class(phase) == "character"){
if(tolower(phase) != "default"){
warning("phase misspecified: please set to 'default' or list with the same order as parameters.")
}
}
}
step = 5
if(!is.null(phase) & estimateMode %in% c(0,1) ){
if(verbose > 0) {message(paste0("Step ", step,": Phasing begin"))}
phase_pars <- Rceattle::TMBphase(
data = data_list_reorganized,
parameters = start_par,
map = map$mapFactor,
random = random_vars,
phases = phase,
model_name = TMBfilename,
silent = verbose != 2,
use_gradient = use_gradient,
control = control
)
start_par <- phase_pars
if(verbose > 0) {message(paste0("Step ", step,": Phasing complete - getting final estimates"))}
step = step + 1
}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 9: Fit hindcast ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if(estimateMode != 2){ # dont build if projection and estimating HCR parameters
if(sum(as.numeric(unlist(map$mapFactor)), na.rm = TRUE) == 0){stop("Map of length 0: all NAs")}
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
random = random_vars,
silent = verbose != 2
)
}
start_par$ln_rec_sigma
map$mapFactor$ln_rec_sigma
random_vars
obj$par
start_par$rec_dev
start_par$init_dev
obj$gr()
start_par$init_dev <- matrix(0, 3,21)
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
random = random_vars,
silent = verbose != 2
)
obj$gr()
start_par$init_dev <- matrix(9, 3,21)
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
random = random_vars,
silent = verbose != 2
)
obj$gr()
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = NULL,
verbose = 1)
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = NULL, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = FALSE, # No random recruitment
msmMode = 0, # Single species mode
phase = "default",
verbose = 1)
ss_run <- Rceattle::fit_mod(data_list = mydata,
inits = ss_run$estimated_params, # Initial parameters = 0
file = NULL, # Don't save
estimateMode = 0, # Estimate
random_rec = TRUE, # No random recruitment
msmMode = 0, # Single species mode
phase = NULL,
verbose = 1)
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Debugging section ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
data_list = NULL;
inits = NULL;
map = NULL;
bounds = NULL;
file = NULL;
estimateMode = 0;
random_rec = FALSE;
random_q = FALSE;
random_sel = FALSE;
HCR = build_hcr();
niter = 3;
msmMode = 0;
avgnMode = 0;
initMode = 1
updateM1 = TRUE;
minNByage = 0;
suitMode = 0;
meanyr = NULL;
phase = NULL;
getsd = TRUE;
use_gradient = TRUE;
rel_tol = 1;
control = list(eval.max = 1e+09,
iter.max = 1e+09, trace = 0);
getJointPrecision = TRUE;
loopnum = 5;
verbose = 1;
newtonsteps = 0
recFun = build_srr()
M1Fun = build_M1()
projection_uncertainty = TRUE
data_list = mydata
inits = ss_run$estimated_params
estimateMode = 0
random_rec = TRUE
msmMode = 0
phase = NULL
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 0 - Start ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
start_time <- Sys.time()
extend_length <- function(x){
if(length(x) == data_list$nspp){ return(x)}
else {return(rep(x, data_list$nspp))}
}
setwd(getwd())
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 1 - Load data ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.null(data_list)) {
stop("Missing data_list object")
}
data_list <- Rceattle::clean_data(data_list)
# Switches
data_list$random_rec <- as.numeric(random_rec)
data_list$estimateMode <- estimateMode
data_list$niter <- niter
data_list$avgnMode <- avgnMode
if(is.null(data_list$initMode)){
data_list$initMode <- initMode
}
data_list$msmMode <- msmMode
data_list$suitMode <- as.numeric(suitMode)
data_list$minNByage <- as.numeric(minNByage)
if(is.null(meanyr) & is.null(data_list$meanyr)){ # If no meanyear is provided in data or function, use end year
data_list$meanyr <- data_list$endyr
}
if(!is.null(meanyr)){ # If mean year is provided in function, override data
data_list$meanyr <- meanyr
}
# Recruitment switches
data_list$srr_fun <- recFun$srr_fun
data_list$srr_pred_fun <- recFun$srr_pred_fun
data_list$proj_mean_rec <- recFun$proj_mean_rec
data_list$srr_est_mode <- recFun$srr_est_mode
data_list$srr_prior_mean <- extend_length(recFun$srr_prior_mean)
data_list$srr_prior_sd <- extend_length(recFun$srr_prior_sd)
# M1
if(is.null(data_list$M1_model)){
data_list$M1_model= extend_length(M1Fun$M1_model)
}
# FIXME: may want to pull from data here too
updateM1 = M1Fun$updateM1
data_list$M1_use_prior = extend_length(M1Fun$M1_use_prior) * (data_list$M1_model > 0) # Sets to 0 if M1 is fixed
data_list$M2_use_prior = extend_length(M1Fun$M2_use_prior) * (msmMode > 0) # Sets to 0 if single-species
data_list$M1_prior_mean = extend_length(M1Fun$M1_prior_mean)
data_list$M1_prior_sd = extend_length(M1Fun$M1_prior_sd)
# HCR Switches (make length of nspp if not)
data_list$HCR = HCR$HCR
data_list$DynamicHCR = HCR$DynamicHCR
if(HCR$HCR != 2){ # FsprTarget is also used for fixed F (so may be of length nflts)
data_list$FsprTarget = extend_length(HCR$FsprTarget)
} else {
data_list$FsprTarget = HCR$FsprTarget
}
data_list$FsprLimit = extend_length(HCR$FsprLimit)
data_list$Ptarget = extend_length(HCR$Ptarget)
data_list$Plimit = extend_length(HCR$Plimit)
data_list$Alpha = extend_length(HCR$Alpha)
data_list$Pstar = extend_length(HCR$Pstar)
data_list$Sigma = extend_length(HCR$Sigma)
data_list$Fmult = extend_length(HCR$Fmult)
data_list$QnormHCR = qnorm(data_list$Pstar, 0, data_list$Sigma)
if(data_list$HCR == 2 & estimateMode == 2){estimateMode = 4} # If projecting under constant F, run parmeters through obj only
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 2: Load/build parameters ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.character(inits) | is.null(inits)) {
start_par <- suppressWarnings(Rceattle::build_params(data_list = data_list))
} else{
start_par <- inits
}
if(verbose > 0) {message("Step 1: Parameter build complete")}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 3: Load/build map ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.null(map)) {
map <- suppressWarnings(build_map(data_list, start_par, debug = estimateMode > 3, random_rec = random_rec))
} else{
map <- map
}
if(verbose > 0) {message("Step 2: Map build complete")}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 4: Get bounds ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if (is.null(bounds)) {
bounds <- Rceattle::build_bounds(param_list = start_par, data_list)
} else {
bounds = bounds
}
if(verbose > 0) {message("Step 3: Param bounds complete")}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 5: Setup random effects ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
random_vars <- c()
if (random_rec) {
if(initMode > 0){
random_vars <- c(random_vars , "rec_dev", "init_dev")
} else{
random_vars <- c(random_vars , "rec_dev")
}
}
if(random_q){
random_vars <- c(random_vars , "ln_srv_q_dev")
}
if(random_sel){
random_vars <- c(random_vars , "ln_sel_slp_dev", "sel_inf_dev", "sel_coff_dev")
}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 6: Reorganize data ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
TMBfilename <- "ceattle_v01_10"
Rceattle:::data_check(data_list)
data_list_reorganized <- Rceattle::rearrange_dat(data_list)
data_list_reorganized = c(list(model = TMBfilename), data_list_reorganized)
if(msmMode > 0 & data_list$HCR == 3){
data_list_reorganized$HCR = 0 # Estimate model with F = 0 for the projection if multispecies
}
data_list_reorganized$forecast <- FALSE # Don't include BRPs in likelihood of hindcast
# - Update comp weights, future F (if input) and F_prop from data
if(!is.null(data_list$fleet_control$Comp_weights)){
start_par$comp_weights = data_list$fleet_control$Comp_weights
}
start_par$proj_F_prop = data_list$fleet_control$proj_F_prop
nyrs_proj <- data_list$projyr - data_list$styr + 1
if(!is.null(HCR$FsprTarget) & HCR$HCR == 2){
start_par$ln_Ftarget = HCR$FsprTarget # Fixed fishing mortality for projections for each species
}
# - Update M1 parameter object from data if initial parameter values input
if(updateM1){
m1 <- array(0, dim = c(data_list$nspp, 2, max(data_list$nages, na.rm = T))) # Set up array
# Initialize from inputs
for (i in 1:nrow(data_list$M1_base)) {
sp <- as.numeric(as.character(data_list$M1_base$Species[i]))
sex <- as.numeric(as.character(data_list$M1_base$Sex[i]))
# Fill in M1 array from fixed values for each sex
if(sex == 0){ sex = c(1, 2)} # If sex = combined/both males and females, fill in both dimensions
for(j in 1:length(sex)){
m1[sp, sex[j], 1:max(data_list$nages, na.rm = T)] <- as.numeric(data_list$M1_base[i,(1:max(data_list$nages, na.rm = T)) + 2])
}
}
start_par$ln_M1 <- log(m1)
}
# - Update alpha for stock-recruit if fixed/prior and initial parameter values input
if(data_list$srr_est_mode %in% c(0,2)){
start_par$rec_pars[,2] <- log(data_list$srr_prior_mean)
}
if(verbose > 0) {message("Step 4: Data rearranged complete")}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 7: Set up parameter bounds ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
L <- c()
U <- c()
for(i in 1:length(map$mapFactor)){
if(names(map$mapFactor)[i] %!in% random_vars){ # Dont have bounds for random effects
L = c(L, unlist(bounds$lower[[i]])[which(!is.na(unlist(map$mapFactor[[i]])) & !duplicated(unlist(map$mapFactor[[i]])))])
U = c(U, unlist(bounds$upper[[i]])[which(!is.na(unlist(map$mapFactor[[i]])) & !duplicated(unlist(map$mapFactor[[i]])))])
}
}
# Dimension check
dim_check <- sapply(start_par, unlist(length)) == sapply(map$mapFactor, unlist(length))
if(sum(dim_check) != length(dim_check)){
stop(print(paste0("Map and parameter objects are not the same size for: ", names(dim_check)[which(dim_check == FALSE)])))
}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 8: Phase hindcast ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Set default phasing
if(!is.null(phase)){
if(class(phase) == "character"){
if(tolower(phase) == "default"){
phase = list(
dummy = 1,
ln_pop_scalar = 4, # Scalar for input numbers-at-age
rec_pars = 1, # Stock-recruit parameters or log(mean rec) if no stock-recruit relationship
ln_rec_sigma = 2, # Variance for annual recruitment deviats
rec_dev = 2, # Annual recruitment deviats
init_dev = 2, # Age specific initial age-structure deviates or parameters
ln_sex_ratio_sigma = 3, # Variance of sex ratio (usually fixed)
ln_M1 = 4, #  Estimated natural or residual mortality
ln_mean_F = 1, # Mean fleet-specific fishing mortality
ln_Flimit = 3, # Estimated F limit
ln_Ftarget = 3, # Estimated F target
ln_Finit = 3, # Estimated fishing mortality for non-equilibrium initial age-structure
proj_F_prop = 1, # Fixed fleet-specific proportion of Flimit and Ftarget apportioned within each species
F_dev = 1, # Annual fleet specific fishing mortality deviates
ln_srv_q = 3, # Survey catchability
ln_srv_q_dev = 5, # Annual survey catchability deviates (if time-varying)
ln_sigma_srv_q = 4, # Prior SD for survey catchability deviates
ln_sigma_time_varying_srv_q = 4, # SD for annual survey catchability deviates (if time-varying)
sel_coff = 3, # Non-parametric selectivity coefficients
sel_coff_dev = 4, # Annual deviates for non-parametric selectivity coefficients
ln_sel_slp = 3, # Slope parameters for logistic forms of selectivity
sel_inf = 3, # Asymptote parameters for logistic forms of selectivity
ln_sel_slp_dev = 5, # Annual deviates for slope parameters for logistic forms of selectivity (if time-varying)
sel_inf_dev = 5, # Annual deviates for asymptote parameters for logistic forms of selectivity (if time-varying)
ln_sigma_sel = 4, # SD for annual selectivity deviates (if time-varying)
sel_curve_pen = 4, # Penalty for non-parametric selectivity
ln_sigma_srv_index = 2, # Log SD for survey lognormal index likelihood (usually input)
ln_sigma_fsh_catch = 2, # Log SD for lognormal catch likelihood (usually input)
comp_weights = 4, # Weights for multinomial comp likelihood
logH_1 = 6,  # Functional form parameter (not used in MSVPA functional form)
logH_1a = 6, # Functional form parameter (not used in MSVPA functional form)
logH_1b = 6, # Functional form parameter (not used in MSVPA functional form)
logH_2 = 6, # Functional form parameter (not used in MSVPA functional form)
logH_3 = 6, # Functional form parameter (not used in MSVPA functional form)
H_4 = 6, # Functional form parameter (not used in MSVPA functional form)
log_gam_a = 5, # Suitability parameter (not used in MSVPA style)
log_gam_b = 5, # Suitability parameter (not used in MSVPA style)
log_phi = 5 # Suitability parameter (not used in MSVPA style)
)
# debugphase = list(
#   dummy = 1,
#   ln_pop_scalar = 5, # Scalar for input numbers-at-age
#   rec_pars = 1, # Stock-recruit parameters or log(mean rec) if no stock-recruit relationship
#   ln_rec_sigma = 4, # Variance for annual recruitment deviats
#   rec_dev = 2, # Annual recruitment deviats
#   init_dev = 3, # Age specific initial age-structure deviates or parameters
#   ln_sex_ratio_sigma = 3, # Variance of sex ratio (usually fixed)
#   ln_M1 = 4, #  Estimated natural or residual mortality
#   ln_mean_F = 6, # Mean fleet-specific fishing mortality
#   ln_Flimit = 15, # Estimated F limit
#   ln_Ftarget = 15, # Estimated F target
#   ln_Finit = 7, # Estimated fishing mortality for non-equilibrium initial age-structure
#   proj_F_prop = 14, # Fixed fleet-specific proportion of Flimit and Ftarget apportioned within each species
#   F_dev = 7, # Annual fleet specific fishing mortality deviates
#   ln_srv_q = 10, # Survey catchability
#   ln_srv_q_dev = 11, # Annual survey catchability deviates (if time-varying)
#   ln_sigma_srv_q = 15, # Prior SD for survey catchability deviates
#   ln_sigma_time_varying_srv_q = 15, # SD for annual survey catchability deviates (if time-varying)
#   sel_coff = 8, # Non-parametric selectivity coefficients
#   sel_coff_dev = 11, # Annual deviates for non-parametric selectivity coefficients
#   ln_sel_slp = 9, # Slope parameters for logistic forms of selectivity
#   sel_inf = 9, # Asymptote parameters for logistic forms of selectivity
#   ln_sel_slp_dev = 11, # Annual deviates for slope parameters for logistic forms of selectivity (if time-varying)
#   sel_inf_dev = 11, # Annual deviates for asymptote parameters for logistic forms of selectivity (if time-varying)
#   ln_sigma_sel = 12, # SD for annual selectivity deviates (if time-varying)
#   sel_curve_pen = 13, # Penalty for non-parametric selectivity
#   ln_sigma_srv_index = 14, # Log SD for survey lognormal index likelihood (usually input)
#   ln_sigma_fsh_catch = 14, # Log SD for lognormal catch likelihood (usually input)
#   comp_weights = 15, # Weights for multinomial comp likelihood
#   logH_1 = 15,  # Functional form parameter (not used in MSVPA functional form)
#   logH_1a = 15, # Functional form parameter (not used in MSVPA functional form)
#   logH_1b = 15, # Functional form parameter (not used in MSVPA functional form)
#   logH_2 = 15, # Functional form parameter (not used in MSVPA functional form)
#   logH_3 = 15, # Functional form parameter (not used in MSVPA functional form)
#   H_4 = 15, # Functional form parameter (not used in MSVPA functional form)
#   log_gam_a = 15, # Suitability parameter (not used in MSVPA style)
#   log_gam_b = 15, # Suitability parameter (not used in MSVPA style)
#   log_phi = 15 # Suitability parameter (not used in MSVPA style)
# )
}
}
if(class(phase) == "character"){
if(tolower(phase) != "default"){
warning("phase misspecified: please set to 'default' or list with the same order as parameters.")
}
}
}
step = 5
if(!is.null(phase) & estimateMode %in% c(0,1) ){
if(verbose > 0) {message(paste0("Step ", step,": Phasing begin"))}
phase_pars <- Rceattle::TMBphase(
data = data_list_reorganized,
parameters = start_par,
map = map$mapFactor,
random = random_vars,
phases = phase,
model_name = TMBfilename,
silent = verbose != 2,
use_gradient = use_gradient,
control = control
)
start_par <- phase_pars
if(verbose > 0) {message(paste0("Step ", step,": Phasing complete - getting final estimates"))}
step = step + 1
}
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# STEP 9: Fit hindcast ----
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
if(estimateMode != 2){ # dont build if projection and estimating HCR parameters
if(sum(as.numeric(unlist(map$mapFactor)), na.rm = TRUE) == 0){stop("Map of length 0: all NAs")}
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
random = random_vars,
silent = verbose != 2
)
}
obj$gr()
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
silent = verbose != 2
)
obj$gr()
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
random = random_vars,
silent = verbose != 2
)
quantities <- obj$report(obj$env$last.par.best)
quantities$jnll_comp
quantities$jnll_comp[12,]
quantities$jnll_comp[11,]
map$mapFactor$init_dev
map$mapFactor$init_dev <- factor(map$mapList$init_dev * NA)
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
random = random_vars,
silent = verbose != 2
)
obj$gr()
map$mapFactor$rec_dev <- factor(map$mapList$rec_dev
* NA)
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
random = random_vars,
silent = verbose != 2
)
obj$gr()
map <- suppressWarnings(build_map(data_list, start_par, debug = estimateMode > 3, random_rec = random_rec))
map$mapFactor$rec_dev <- factor(map$mapList$rec_dev
* NA)
obj = TMB::MakeADFun(
data_list_reorganized,
parameters = start_par,
DLL = TMBfilename,
map = map$mapFactor,
random = random_vars,
silent = verbose != 2
)
obj$gr()
random_vars
start_par$rec_dev
map$mapList
map$mapList$rec_dev
start_par$rec_dev
